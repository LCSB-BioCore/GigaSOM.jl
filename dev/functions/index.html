<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Functions · GigaSOM.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://lcsb-biocore.github.io/GigaSOM.jl/stable/functions/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><script src="../../copy.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/gigasomlogotransp.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="GigaSOM.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">GigaSOM.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../background/">Background</a></li><li><span class="tocitem">Tutorial</span><ul><li><a class="tocitem" href="../tutorials/basicUsage/">Introduction</a></li><li><a class="tocitem" href="../tutorials/processingFCSData/">Cytometry data</a></li><li><a class="tocitem" href="../tutorials/distributedProcessing/">Advanced distributed processing</a></li><li><a class="tocitem" href="../tutorials/whereToGoNext/">Conclusion</a></li></ul></li><li class="is-active"><a class="tocitem" href>Functions</a><ul class="internal"><li><a class="tocitem" href="#Data-structures"><span>Data structures</span></a></li><li><a class="tocitem" href="#Data-loading-and-preparation"><span>Data loading and preparation</span></a></li><li><a class="tocitem" href="#SOM-training"><span>SOM training</span></a></li><li><a class="tocitem" href="#Embedding"><span>Embedding</span></a></li><li><a class="tocitem" href="#Distributed-processing-tools"><span>Distributed processing tools</span></a></li></ul></li><li><a class="tocitem" href="../howToContribute/">How to contribute</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Functions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Functions</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/master/docs/src/functions.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Functions"><a class="docs-heading-anchor" href="#Functions">Functions</a><a id="Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Functions" title="Permalink"></a></h1><h2 id="Data-structures"><a class="docs-heading-anchor" href="#Data-structures">Data structures</a><a id="Data-structures-1"></a><a class="docs-heading-anchor-permalink" href="#Data-structures" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.LoadedDataInfo" href="#GigaSOM.LoadedDataInfo"><code>GigaSOM.LoadedDataInfo</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LoadedDataInfo</code></pre><p>The basic structure for working with loaded data, distributed amongst workers. In completeness, it represents a dataset as such:</p><ul><li><code>val</code> is the &quot;value name&quot; under which the data are saved in processes. E.g. <code>val=:foo</code> means that there is a variable <code>foo</code> on each process holding a part of the matrix.</li><li><code>workers</code> is a list of workers (in correct order!) that hold the data (similar to <code>DArray.pids</code>)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/7a0772a96800f58e6fcf9dce479eb83232aba375/src/base/structs.jl#L39-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.Som" href="#GigaSOM.Som"><code>GigaSOM.Som</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Som</code></pre><p>Structure to hold all data of a trained SOM.</p><p><strong>Fields:</strong></p><ul><li><code>codes::Array{Float64,2}</code>: 2D-array of codebook vectors. One vector per row</li><li><code>xdim::Int</code>: number of neurons in x-direction</li><li><code>ydim::Int</code>: number of neurons in y-direction</li><li><code>numCodes::Int</code>: total number of neurons</li><li><code>grid::Array{Float64,2}</code>: 2D-array of coordinates of neurons on the map         (2 columns (x,y)] for rectangular and hexagonal maps          3 columns (x,y,z) for spherical maps)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/7a0772a96800f58e6fcf9dce479eb83232aba375/src/base/structs.jl#L1-L14">source</a></section></article><h2 id="Data-loading-and-preparation"><a class="docs-heading-anchor" href="#Data-loading-and-preparation">Data loading and preparation</a><a id="Data-loading-and-preparation-1"></a><a class="docs-heading-anchor-permalink" href="#Data-loading-and-preparation" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.distributeFCSFileVector" href="#GigaSOM.distributeFCSFileVector"><code>GigaSOM.distributeFCSFileVector</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">distributeFCSFileVector(name::Symbol, fns::Vector{String}, pids=workers())::LoadedDataInfo</code></pre><p>Distribute a vector of integers among the workers that describes which file from <code>fns</code> the cell comes from. Useful for producing per-file statistics. The vector is saved on workers specified by <code>pids</code> as a distributed variable <code>name</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/7a0772a96800f58e6fcf9dce479eb83232aba375/src/io/input.jl#L169-L176">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.distributeFileVector" href="#GigaSOM.distributeFileVector"><code>GigaSOM.distributeFileVector</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">distributeFileVector(name::Symbol, sizes::Vector{Int}, slices::Vector{Tuple{Int,Int,Int,Int}}, pids=workers())::LoadedDataInfo</code></pre><p>Generalized version of <code>distributeFCSFileVector</code> that produces the integer vector from any <code>sizes</code> and <code>slices</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/7a0772a96800f58e6fcf9dce479eb83232aba375/src/io/input.jl#L187-L192">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.getCSVSize-Tuple{String}" href="#GigaSOM.getCSVSize-Tuple{String}"><code>GigaSOM.getCSVSize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function getCSVSize(fn::String; args...)::Tuple{Int,Int}</code></pre><p>Read the dimensions (number of rows and columns, respectively) from a CSV file <code>fn</code>. <code>args</code> are passed to function <code>CSV.file</code>.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">getCSVSize(&quot;test.csv&quot;, header=false)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/7a0772a96800f58e6fcf9dce479eb83232aba375/src/io/input.jl#L208-L217">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.getFCSSize-Tuple{Any, Any}" href="#GigaSOM.getFCSSize-Tuple{Any, Any}"><code>GigaSOM.getFCSSize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getFCSSize(offsets, params)::Tuple{Int,Int}</code></pre><p>Convert the offsets and keywords from an FCS file to cell and parameter count, respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/7a0772a96800f58e6fcf9dce479eb83232aba375/src/io/input.jl#L15-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.loadCSV-Tuple{String}" href="#GigaSOM.loadCSV-Tuple{String}"><code>GigaSOM.loadCSV</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function loadCSV(fn::String; args...)::Matrix{Float64}</code></pre><p>CSV equivalent of <code>loadFCS</code>. The metadata (header, column names) are not extracted. <code>args</code> are passed to <code>CSV.read</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/7a0772a96800f58e6fcf9dce479eb83232aba375/src/io/input.jl#L241-L246">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.loadCSVSet" href="#GigaSOM.loadCSVSet"><code>GigaSOM.loadCSVSet</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">function loadCSVSet(
    name::Symbol,
    fns::Vector{String},
    pids = workers();
    postLoad = (d, i) -&gt; d,
    csvargs...,
)::LoadedDataInfo</code></pre><p>CSV equivalent of <code>loadFCSSet</code>. <code>csvargs</code> are passed as keyword arguments to CSV-loading functions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/7a0772a96800f58e6fcf9dce479eb83232aba375/src/io/input.jl#L251-L262">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.loadCSVSizes-Tuple{Vector{String}}" href="#GigaSOM.loadCSVSizes-Tuple{Vector{String}}"><code>GigaSOM.loadCSVSizes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function loadCSVSizes(fns::Vector{String}; args...)::Vector{Int}</code></pre><p>Determine number of rows in a list of CSV files (passed as <code>fns</code>). Equivalent to <code>loadFCSSizes</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/7a0772a96800f58e6fcf9dce479eb83232aba375/src/io/input.jl#L231-L236">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.loadFCS-Tuple{String}" href="#GigaSOM.loadFCS-Tuple{String}"><code>GigaSOM.loadFCS</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">loadFCS(fn::String; applyCompensation::Bool=true)::Tuple{Dict{String,String}, Matrix{Float64}}</code></pre><p>Read a FCS file. Return a tuple that contains in order:</p><ul><li>dictionary of the keywords contained in the file</li><li>raw column names</li><li>prettified and annotated column names</li><li>raw data matrix</li></ul><p>If <code>applyCompensation</code> is set, the function parses and retrieves a spillover matrix (if any valid keyword in the FCS is found that would contain it) and applies it to compensate the data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/7a0772a96800f58e6fcf9dce479eb83232aba375/src/io/input.jl#L62-L75">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.loadFCSHeader-Tuple{String}" href="#GigaSOM.loadFCSHeader-Tuple{String}"><code>GigaSOM.loadFCSHeader</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">loadFCSHeader(fn::String)::Tuple{Vector{Int}, Dict{String,String}}</code></pre><p>Efficiently extract data offsets and keyword dictionary from an FCS file.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/7a0772a96800f58e6fcf9dce479eb83232aba375/src/io/input.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.loadFCSSet" href="#GigaSOM.loadFCSSet"><code>GigaSOM.loadFCSSet</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">loadFCSSet(name::Symbol, fns::Vector{String}, pids=workers(); applyCompensation=true, postLoad=(d,i)-&gt;d)::LoadedDataInfo</code></pre><p>This runs the FCS loading machinery in a distributed way, so that the files <code>fns</code> (with full path) are sliced into equal parts and saved as a distributed variable <code>name</code> on workers specified by <code>pids</code>.</p><p><code>applyCompensation</code> is passed to loadFCS function.</p><p>See <code>slicesof</code> for description of the slicing.</p><p><code>postLoad</code> is applied to the loaded FCS file data (and the index) – use this function to e.g. filter out certain columns right on loading, using <code>selectFCSColumns</code>.</p><p>The loaded dataset can be manipulated by the distributed functions, e.g.</p><ul><li><code>dselect</code> for removing columns</li><li><code>dscale</code> for normalization</li><li><code>dtransform_asinh</code> (and others) for transformation</li><li>etc.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/7a0772a96800f58e6fcf9dce479eb83232aba375/src/io/input.jl#L98-L117">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.loadFCSSizes-Tuple{Vector{String}}" href="#GigaSOM.loadFCSSizes-Tuple{Vector{String}}"><code>GigaSOM.loadFCSSizes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">loadFCSSizes(fns::Vector{String})</code></pre><p>Load cell counts in many FCS files at once. Useful as input for <code>slicesof</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/7a0772a96800f58e6fcf9dce479eb83232aba375/src/io/input.jl#L48-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.selectFCSColumns-Tuple{Vector{String}}" href="#GigaSOM.selectFCSColumns-Tuple{Vector{String}}"><code>GigaSOM.selectFCSColumns</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">selectFCSColumns(selectColnames::Vector{String})</code></pre><p>Return a function useful with <code>loadFCSSet</code>, which loads only the specified (prettified) column names from the FCS files. Use <code>getMetaData</code>, <code>getMarkerNames</code> and <code>cleanNames!</code> to retrieve the usable column names for a FCS.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/7a0772a96800f58e6fcf9dce479eb83232aba375/src/io/input.jl#L148-L155">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.cleanNames!-Tuple{Vector{String}}" href="#GigaSOM.cleanNames!-Tuple{Vector{String}}"><code>GigaSOM.cleanNames!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cleanNames!(mydata::Vector{String})</code></pre><p>Replaces problematic characters in column names, avoids duplicate names, and prefixes an &#39;_&#39; if the name starts with a number.</p><p><strong>Arguments:</strong></p><ul><li><code>mydata</code>: vector of names (gets modified)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/7a0772a96800f58e6fcf9dce479eb83232aba375/src/io/process.jl#L1-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.compensate!-Tuple{Matrix{Float64}, Matrix{Float64}, Vector{Int64}}" href="#GigaSOM.compensate!-Tuple{Matrix{Float64}, Matrix{Float64}, Vector{Int64}}"><code>GigaSOM.compensate!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">compensate!(data::Matrix{Float64}, spillover::Matrix{Float64}, cols::Vector{Int})</code></pre><p>Apply a compensation matrix in <code>spillover</code> (the individual columns of which describe, in order, the spillover of <code>cols</code> in <code>data</code>) to the matrix <code>data</code> in-place.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/7a0772a96800f58e6fcf9dce479eb83232aba375/src/io/process.jl#L101-L107">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.getMarkerNames-Tuple{DataFrames.DataFrame}" href="#GigaSOM.getMarkerNames-Tuple{DataFrames.DataFrame}"><code>GigaSOM.getMarkerNames</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getMarkerNames(meta::DataFrame)::Tuple{Vector{String}, Vector{String}}</code></pre><p>Extract suitable raw names (useful for selecting columns) and pretty readable names (useful for humans) from FCS file metadata.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/7a0772a96800f58e6fcf9dce479eb83232aba375/src/io/process.jl#L80-L86">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.getMetaData-Tuple{Dict{String, String}}" href="#GigaSOM.getMetaData-Tuple{Dict{String, String}}"><code>GigaSOM.getMetaData</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getMetaData(f)</code></pre><p>Collect the meta data information in a more user friendly format.</p><p><strong>Arguments:</strong></p><ul><li><code>f</code>: input structure with <code>.params</code> and <code>.data</code> fields</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/7a0772a96800f58e6fcf9dce479eb83232aba375/src/io/process.jl#L32-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.getSpillover-Tuple{Dict{String, String}}" href="#GigaSOM.getSpillover-Tuple{Dict{String, String}}"><code>GigaSOM.getSpillover</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getSpillover(params::Dict{String, String})::Union{Tuple{Vector{String},Matrix{Float64}}, Nothing}</code></pre><p>Get a spillover matrix from FCS <code>params</code>. Returns a pair with description of columns to be applied, and with the actual spillover matrix. Returns <code>nothing</code> in case spillover is not present.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/7a0772a96800f58e6fcf9dce479eb83232aba375/src/io/process.jl#L131-L137">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.parseSpillover-Tuple{String}" href="#GigaSOM.parseSpillover-Tuple{String}"><code>GigaSOM.parseSpillover</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">parseSpillover(str::String)::Union{Tuple{Vector{String},Matrix{Float64}}, Nothing}</code></pre><p>Parses the spillover matrix from the string from FCS parameter value.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/7a0772a96800f58e6fcf9dce479eb83232aba375/src/io/process.jl#L112-L116">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.collectSlice-Tuple{Any, NTuple{4, Int64}}" href="#GigaSOM.collectSlice-Tuple{Any, NTuple{4, Int64}}"><code>GigaSOM.collectSlice</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">collectSlice(loadVec, (startFile, startOff, finalFile, finalOff)::Tuple{Int,Int,Int,Int})::Vector</code></pre><p>Alternative of <code>vcollectSlice</code> for 1D vectors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/7a0772a96800f58e6fcf9dce479eb83232aba375/src/io/splitting.jl#L92-L96">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.slicesof-Tuple{Vector{Int64}, Int64}" href="#GigaSOM.slicesof-Tuple{Vector{Int64}, Int64}"><code>GigaSOM.slicesof</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">slicesof(lengths::Vector{Int}, slices::Int)::Vector{Tuple{Int,Int,Int,Int}}</code></pre><p>Given a list of <code>lengths</code> of input arrays, compute a slicing into a specified amount of equally-sized <code>slices</code>.</p><p>The output is a vector of 4-tuples where each specifies how to create one slice. The i-th tuple field contains, in order:</p><ul><li>the index of input array at which the i-th slice begins</li><li>first element of the i-th slice in that input array</li><li>the index of input array with the last element of the i-th slice</li><li>the index of the last element of the i-th slice in that array</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/7a0772a96800f58e6fcf9dce479eb83232aba375/src/io/splitting.jl#L1-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.vcollectSlice-Tuple{Any, NTuple{4, Int64}}" href="#GigaSOM.vcollectSlice-Tuple{Any, NTuple{4, Int64}}"><code>GigaSOM.vcollectSlice</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">vcollectSlice(loadMtx, (startFile, startOff, finalFile, finalOff)::Tuple{Int,Int,Int,Int})::Matrix</code></pre><p>Given a method to obtain matrix content (<code>loadMtx</code>), reconstruct a slice from the information generated by <code>slicesof</code>.</p><p>This function is specialized for reconstructing matrices and arrays, where the &quot;element counts&quot; split by <code>slicesof</code> are in fact matrix rows. The function is therefore named <em>v</em>collect (the slicing and concatenation is <em>v</em>ertical).</p><p>The actual data content and loading method is abstracted out – function <code>loadMtx</code> gets the index of the input part that it is required to fetch (e.g. index of one FCS file), and is expected to return that input part as a whole matrix. <code>vcollectSlice</code> correctly calls this function as required and extracts relevant portions of the matrices, so that at the end the whole slice can be pasted together.</p><p>Example:</p><pre><code class="nohighlight hljs"># get a list of files
filenames=[&quot;a.fcs&quot;, &quot;b.fcs&quot;]
# get descriptions of 5 equally sized parts of the data
slices = slicesof(loadFCSSizes(filenames), 5)

# reconstruct first 3 columns of the first slice
mySlice = vcollectSlice(
    i -&gt; last(loadFCS(slices[i]))[:,1:3],
    slices[1])
# (note: function loadFCS returns 4 items, the matrix is the last one)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/7a0772a96800f58e6fcf9dce479eb83232aba375/src/io/splitting.jl#L48-L77">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.catmapbuckets-Tuple{Any, Array, Int64, Vector{Int64}}" href="#GigaSOM.catmapbuckets-Tuple{Any, Array, Int64, Vector{Int64}}"><code>GigaSOM.catmapbuckets</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">catmapbuckets(fn, a::Array, nbuckets::Int, buckets::Vector{Int}; bucketdim::Int=1)</code></pre><p>Same as <code>mapbuckets</code>, except concatenates the bucketing results in the bucketing dimension, thus creating a slightly neater matrix. <code>slicedims</code> is therefore fixed to <code>bucketdim</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/7a0772a96800f58e6fcf9dce479eb83232aba375/src/base/dataops.jl#L249-L255">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.collect_extrema-Tuple{Any, Any}" href="#GigaSOM.collect_extrema-Tuple{Any, Any}"><code>GigaSOM.collect_extrema</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">collect_extrema(ex1, ex2)</code></pre><p>Helper for collecting the minimums and maximums of the data. <code>ex1</code>, <code>ex2</code> are arrays of pairs (min,max), this function combines the arrays element-wise and finds combined minima and maxima.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/7a0772a96800f58e6fcf9dce479eb83232aba375/src/base/dataops.jl#L277-L283">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.combine_stats-Tuple{Any, Any}" href="#GigaSOM.combine_stats-Tuple{Any, Any}"><code>GigaSOM.combine_stats</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">combine_stats((s1, sqs1, n1), (s2, sqs2, n2))</code></pre><p>Helper for <code>dstat</code>-style functions that just adds up elements in triplets of vectors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/7a0772a96800f58e6fcf9dce479eb83232aba375/src/base/dataops.jl#L78-L83">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.dapply_cols-Tuple{LoadedDataInfo, Any, Vector{Int64}}" href="#GigaSOM.dapply_cols-Tuple{LoadedDataInfo, Any, Vector{Int64}}"><code>GigaSOM.dapply_cols</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dapply_cols(dInfo::LoadedDataInfo, fn, columns::Vector{Int})</code></pre><p>Apply a function <code>fn</code> over columns of a distributed dataset.</p><p><code>fn</code> gets <em>2</em> parameters:</p><ul><li>a data vector for (the whole column saved at one worker)</li><li>index of the column in the <code>columns</code> array (i.e. a number from <code>1:length(columns)</code>)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/7a0772a96800f58e6fcf9dce479eb83232aba375/src/base/dataops.jl#L45-L54">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.dapply_rows-Tuple{LoadedDataInfo, Any}" href="#GigaSOM.dapply_rows-Tuple{LoadedDataInfo, Any}"><code>GigaSOM.dapply_rows</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dapply_rows(dInfo::LoadedDataInfo, fn)</code></pre><p>Apply a function <code>fn</code> over rows of a distributed dataset.</p><p><code>fn</code> gets a single vector parameter for each row to transform.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/7a0772a96800f58e6fcf9dce479eb83232aba375/src/base/dataops.jl#L63-L69">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.dcopy-Tuple{LoadedDataInfo, Symbol}" href="#GigaSOM.dcopy-Tuple{LoadedDataInfo, Symbol}"><code>GigaSOM.dcopy</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dcopy(dInfo::LoadedDataInfo, newName::Symbol)</code></pre><p>Clone the dataset and store it under a new distributed name <code>newName</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/7a0772a96800f58e6fcf9dce479eb83232aba375/src/base/dataops.jl#L2-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.dcount-Tuple{Int64, LoadedDataInfo}" href="#GigaSOM.dcount-Tuple{Int64, LoadedDataInfo}"><code>GigaSOM.dcount</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dcount(ncats::Int, dInfo::LoadedDataInfo)::Vector{Int}</code></pre><p>Count the numbers of integer vector values stored in <code>dInfo</code>; assuming the values are in range 1–<code>ncats</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/7a0772a96800f58e6fcf9dce479eb83232aba375/src/base/dataops.jl#L148-L153">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.dcount_buckets-Tuple{Int64, LoadedDataInfo, Int64, LoadedDataInfo}" href="#GigaSOM.dcount_buckets-Tuple{Int64, LoadedDataInfo, Int64, LoadedDataInfo}"><code>GigaSOM.dcount_buckets</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dcount_buckets(ncats::Int, dInfo::LoadedDataInfo, nbuckets::Int, buckets::LoadedDataInfo)::Matrix{Int}</code></pre><p>Same as <code>dcount</code>, but counts the items in <code>dInfo</code> bucketed by <code>buckets</code> to produce a matrix of counts, with <code>ncats</code> rows and <code>nbuckets</code> columns.</p><p>Useful with <code>distributeFCSFileVector</code> to determine cluster distribution within files.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/7a0772a96800f58e6fcf9dce479eb83232aba375/src/base/dataops.jl#L166-L174">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.dmedian-Tuple{LoadedDataInfo, Vector{Int64}}" href="#GigaSOM.dmedian-Tuple{LoadedDataInfo, Vector{Int64}}"><code>GigaSOM.dmedian</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dmedian(dInfo::LoadedDataInfo, columns::Vector{Int})</code></pre><p>Compute a median in a distributed fashion, avoiding data transfer and memory capacity that is required to compute the median in the classical way by sorting. All data must be finite and defined. If the median is just between 2 values, the lower one is chosen.</p><p>The algorithm is approximative, searching for a good median by halving interval and counting how many values are below the threshold. <code>iters</code> can be increased to improve precision, each value adds roughly 1 bit to the precision. The default value is 20, which corresponds to precision 10e-6 times the data range.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/7a0772a96800f58e6fcf9dce479eb83232aba375/src/base/dataops.jl#L307-L319">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.dmedian_buckets-Tuple{LoadedDataInfo, Int64, LoadedDataInfo, Vector{Int64}}" href="#GigaSOM.dmedian_buckets-Tuple{LoadedDataInfo, Int64, LoadedDataInfo, Vector{Int64}}"><code>GigaSOM.dmedian_buckets</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dmedian_buckets(dInfo::LoadedDataInfo, nbuckets::Int, buckets::LoadedDataInfo, columns::Vector{Int}; iters=20)</code></pre><p>A version of <code>dmedian</code> that works with the bucketing information (i.e. clusters) from <code>nbuckets</code> and <code>buckets</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/7a0772a96800f58e6fcf9dce479eb83232aba375/src/base/dataops.jl#L351-L356">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.dscale-Tuple{LoadedDataInfo, Vector{Int64}}" href="#GigaSOM.dscale-Tuple{LoadedDataInfo, Vector{Int64}}"><code>GigaSOM.dscale</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dscale(dInfo::LoadedDataInfo, columns::Vector{Int})</code></pre><p>Scale the columns in the dataset to have mean 0 and sdev 1.</p><p>Prevents creation of NaNs by avoiding division by zero sdevs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/7a0772a96800f58e6fcf9dce479eb83232aba375/src/base/dataops.jl#L192-L198">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.dselect" href="#GigaSOM.dselect"><code>GigaSOM.dselect</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">dselect(dInfo::LoadedDataInfo, columns::Vector{Int}; tgt=dInfo.val)</code></pre><p>Reduce dataset to selected columns, optionally save it under a different name.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/7a0772a96800f58e6fcf9dce479eb83232aba375/src/base/dataops.jl#L11-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.dselect" href="#GigaSOM.dselect"><code>GigaSOM.dselect</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">function dselect(dInfo::LoadedDataInfo,
    currentColnames::Vector{String}, selectColnames::Vector{String};
    tgt=dInfo.val)::LoadedDataInfo</code></pre><p>Convenience overload of <code>dselect</code> that works with column names.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/7a0772a96800f58e6fcf9dce479eb83232aba375/src/base/dataops.jl#L24-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.dstat-Tuple{LoadedDataInfo, Vector{Int64}}" href="#GigaSOM.dstat-Tuple{LoadedDataInfo, Vector{Int64}}"><code>GigaSOM.dstat</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dstat(dInfo::LoadedDataInfo, columns::Vector{Int})::Tuple{Vector{Float64}, Vector{Float64}}</code></pre><p>Compute mean and standard deviation of the columns in dataset. Returns a tuple with a vector of means in <code>columns</code>, and a vector of corresponding sdevs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/7a0772a96800f58e6fcf9dce479eb83232aba375/src/base/dataops.jl#L88-L93">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.dstat_buckets-Tuple{LoadedDataInfo, Int64, LoadedDataInfo, Vector{Int64}}" href="#GigaSOM.dstat_buckets-Tuple{LoadedDataInfo, Int64, LoadedDataInfo, Vector{Int64}}"><code>GigaSOM.dstat_buckets</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dstat_buckets(dInfo::LoadedDataInfo, nbuckets::Int, buckets::LoadedDataInfo, columns::Vector{Int})::Tuple{Matrix{Float64}, Matrix{Float64}}</code></pre><p>A version of <code>dstat</code> that works with bucketing information (e.g. clusters); returns a tuple of matrices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/7a0772a96800f58e6fcf9dce479eb83232aba375/src/base/dataops.jl#L118-L123">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.dtransform_asinh" href="#GigaSOM.dtransform_asinh"><code>GigaSOM.dtransform_asinh</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">dtransform_asinh(dInfo::LoadedDataInfo, columns::Vector{Int}, cofactor=5)</code></pre><p>Transform columns of the dataset by asinh transformation with <code>cofactor</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/7a0772a96800f58e6fcf9dce479eb83232aba375/src/base/dataops.jl#L208-L212">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.mapbuckets-Tuple{Any, Array, Int64, Vector{Int64}}" href="#GigaSOM.mapbuckets-Tuple{Any, Array, Int64, Vector{Int64}}"><code>GigaSOM.mapbuckets</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mapbuckets(fn, a::Array, nbuckets::Int, buckets::Vector{Int}; bucketdim::Int=1, slicedims=bucketdim)</code></pre><p>Apply the function <code>fn</code> over array <code>a</code> so that it processes the data by buckets defined by <code>buckets</code> (that contains integers in range <code>1:nbuckets</code>).</p><p>The buckets are sliced out in dimension specified by <code>bucketdim</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/7a0772a96800f58e6fcf9dce479eb83232aba375/src/base/dataops.jl#L217-L224">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.update_extrema-NTuple{4, Any}" href="#GigaSOM.update_extrema-NTuple{4, Any}"><code>GigaSOM.update_extrema</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">update_extrema(counts, target, lim, mid)</code></pre><p>Helper for distributed median computation – returns updated extrema in <code>lims</code> depending on whether the item count in <code>counts</code> of values less than <code>mids</code> is less or higher than <code>targets</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/7a0772a96800f58e6fcf9dce479eb83232aba375/src/base/dataops.jl#L288-L294">source</a></section></article><h2 id="SOM-training"><a class="docs-heading-anchor" href="#SOM-training">SOM training</a><a id="SOM-training-1"></a><a class="docs-heading-anchor-permalink" href="#SOM-training" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.distributedEpoch-Tuple{LoadedDataInfo, Matrix{Float64}, Any}" href="#GigaSOM.distributedEpoch-Tuple{LoadedDataInfo, Matrix{Float64}, Any}"><code>GigaSOM.distributedEpoch</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">distributedEpoch(dInfo::LoadedDataInfo, codes::Matrix{Float64}, tree)</code></pre><p>Execute the <code>doEpoch</code> in parallel on workers described by <code>dInfo</code> and collect the results. Returns pair of numerator and denominator matrices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/7a0772a96800f58e6fcf9dce479eb83232aba375/src/analysis/core.jl#L217-L222">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.doEpoch-Tuple{Matrix{Float64}, Matrix{Float64}, Any}" href="#GigaSOM.doEpoch-Tuple{Matrix{Float64}, Matrix{Float64}, Any}"><code>GigaSOM.doEpoch</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">doEpoch(x::Array{Float64, 2}, codes::Array{Float64, 2}, tree)</code></pre><p>vectors and the adjustment in radius after each epoch.</p><p><strong>Arguments:</strong></p><ul><li><code>x</code>: training Data</li><li><code>codes</code>: Codebook</li><li><code>tree</code>: knn-compatible tree built upon the codes</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/7a0772a96800f58e6fcf9dce479eb83232aba375/src/analysis/core.jl#L188-L197">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.initGigaSOM" href="#GigaSOM.initGigaSOM"><code>GigaSOM.initGigaSOM</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">function initGigaSOM(ncol::Int64,
                     means::Vector{Float64}, sdevs::Vector{Float64},
                     xdim::Int64, ydim::Int64 = xdim;
                     seed = rand(Int), rng = StableRNG(seed))</code></pre><p>Generate a stable random initial SOM with the random distribution that matches the parameters.</p><p>Arguments:</p><ul><li><code>ncol</code>: number of desired data columns</li><li><code>means</code>, <code>sdevs</code>: vectors that describe the data distribution, both of size <code>ncol</code></li><li><code>xdim</code>, <code>ydim</code>: Size of the SOM</li><li><code>seed</code>: a seed (defaults to random seed from the current default random generator</li><li><code>rng</code>: a random number generator to be used (defaults to a <code>StableRNG</code> initialized with the <code>seed</code>)</li></ul><p>Returns: a new <code>Som</code> structure</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/7a0772a96800f58e6fcf9dce479eb83232aba375/src/analysis/core.jl#L42-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.initGigaSOM-Tuple{LoadedDataInfo, Vararg{Any}}" href="#GigaSOM.initGigaSOM-Tuple{LoadedDataInfo, Vararg{Any}}"><code>GigaSOM.initGigaSOM</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function initGigaSOM(data::LoadedDataInfo,
                     xdim::Int64, ydim::Int64 = xdim;
                     seed=rand(Int), rng=StableRNG(seed))</code></pre><p><code>initGigaSOM</code> overload for working with distributed-style <code>LoadedDataInfo</code> data. The rest of the arguments is passed to the data-independent <code>initGigaSOM</code>.</p><p>Arguments:</p><ul><li><code>data</code>: a <code>LoadedDataInfo</code> object with the distributed dataset matrix</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/7a0772a96800f58e6fcf9dce479eb83232aba375/src/analysis/core.jl#L23-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.initGigaSOM-Tuple{Union{DataFrames.DataFrame, Matrix}, Vararg{Any}}" href="#GigaSOM.initGigaSOM-Tuple{Union{DataFrames.DataFrame, Matrix}, Vararg{Any}}"><code>GigaSOM.initGigaSOM</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initGigaSOM(data, args...)</code></pre><p>Initializes a SOM by random selection from the training data. A generic overload that works for matrices and DataFrames that can be coerced to <code>Matrix{Float64}</code>. Other arguments are passed to the data-independent <code>initGigaSOM</code>.</p><p>Arguments:</p><ul><li><code>data</code>: matrix of data for running the initialization</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/7a0772a96800f58e6fcf9dce479eb83232aba375/src/analysis/core.jl#L1-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.mapToGigaSOM-Tuple{Som, Any}" href="#GigaSOM.mapToGigaSOM-Tuple{Som, Any}"><code>GigaSOM.mapToGigaSOM</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mapToGigaSOM(som::Som, data;
             knnTreeFun = BruteTree,
             metric = Euclidean())</code></pre><p>Overload of <code>mapToGigaSOM</code> for simple DataFrames and matrices. This slices the data using <code>DistributedArrays</code>, sends them the workers, and runs normal <code>mapToGigaSOM</code>. Data is <code>undistribute</code>d after the computation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/7a0772a96800f58e6fcf9dce479eb83232aba375/src/analysis/core.jl#L266-L273">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.mapToGigaSOM-Tuple{Som, LoadedDataInfo}" href="#GigaSOM.mapToGigaSOM-Tuple{Som, LoadedDataInfo}"><code>GigaSOM.mapToGigaSOM</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mapToGigaSOM(som::Som, dInfo::LoadedDataInfo;
    knnTreeFun = BruteTree, metric = Euclidean(),
    output::Symbol=tmpSym(dInfo)::LoadedDataInfo</code></pre><p>Compute the index of the BMU for each row of the input data.</p><p><strong>Arguments</strong></p><ul><li><code>som</code>: a trained SOM</li><li><code>dInfo</code>: <code>LoadedDataInfo</code> that describes the loaded and distributed data</li><li><code>knnTreeFun</code>: Constructor of the KNN-tree (e.g. from NearestNeighbors package)</li><li><code>metric</code>: Passed as metric argument to the KNN-tree constructor</li><li><code>output</code>: Symbol to save the result, defaults to <code>tmpSym(dInfo)</code></li></ul><p>Data must have the same number of dimensions as the training dataset and will be normalised with the same parameters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/7a0772a96800f58e6fcf9dce479eb83232aba375/src/analysis/core.jl#L232-L248">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.scaleEpochTime-Tuple{Int64, Int64}" href="#GigaSOM.scaleEpochTime-Tuple{Int64, Int64}"><code>GigaSOM.scaleEpochTime</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">scaleEpochTime(iteration::Int64, epochs::Int64)</code></pre><p>Convert iteration ID and epoch number to relative time in training.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/7a0772a96800f58e6fcf9dce479eb83232aba375/src/analysis/core.jl#L291-L295">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.trainGigaSOM-Tuple{Som, Any}" href="#GigaSOM.trainGigaSOM-Tuple{Som, Any}"><code>GigaSOM.trainGigaSOM</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">trainGigaSOM(som::Som, train;
             kwargs...)</code></pre><p>Overload of <code>trainGigaSOM</code> for simple DataFrames and matrices. This slices the data, distributes them to the workers, and runs normal <code>trainGigaSOM</code>. Data is <code>undistribute</code>d after the computation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/7a0772a96800f58e6fcf9dce479eb83232aba375/src/analysis/core.jl#L168-L175">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.trainGigaSOM-Tuple{Som, LoadedDataInfo}" href="#GigaSOM.trainGigaSOM-Tuple{Som, LoadedDataInfo}"><code>GigaSOM.trainGigaSOM</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">trainGigaSOM(
    som::Som,
    dInfo::LoadedDataInfo;
    kernelFun::Function = gaussianKernel,
    metric = Euclidean(),
    somDistFun = distMatrix(Chebyshev()),
    knnTreeFun = BruteTree,
    rStart = 0.0,
    rFinal = 0.1,
    radiusFun = expRadius(-5.0),
    epochs = 20,
    eachEpoch = (e, r, som) -&gt; nothing,
)</code></pre><p><strong>Arguments:</strong></p><ul><li><code>som</code>: object of type Som with an initialised som</li><li><code>dInfo</code>: <code>LoadedDataInfo</code> object that describes a loaded dataset</li><li><code>kernelFun::function</code>: optional distance kernel; one of (<code>bubbleKernel, gaussianKernel</code>)           default is <code>gaussianKernel</code></li><li><code>metric</code>: Passed as metric argument to the KNN-tree constructor</li><li><code>somDistFun</code>: Function for computing the distances in the SOM map</li><li><code>knnTreeFun</code>: Constructor of the KNN-tree (e.g. from NearestNeighbors package)</li><li><code>rStart</code>: optional training radius. If zero (default), it is computed from the SOM grid size.</li><li><code>rFinal</code>: target radius at the last epoch, defaults to 0.1</li><li><code>radiusFun</code>: Function that generates radius decay, e.g. <code>linearRadius</code> or <code>expRadius(10.0)</code></li><li><code>epochs</code>: number of SOM training iterations (default 10)</li><li><code>eachEpoch</code>: a function to call back after each epoch, accepting arguments <code>(epochNumber, radius, som)</code>. For simplicity, this gets additionally called once before the first epoch, with <code>epochNumber</code> set to zero.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/7a0772a96800f58e6fcf9dce479eb83232aba375/src/analysis/core.jl#L84-L114">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.bubbleKernel-Tuple{Any, Float64}" href="#GigaSOM.bubbleKernel-Tuple{Any, Float64}"><code>GigaSOM.bubbleKernel</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">bubbleKernel(x, r::Float64)</code></pre><p>Return a &quot;bubble&quot; (spherical) distribution kernel.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/7a0772a96800f58e6fcf9dce479eb83232aba375/src/base/trainutils.jl#L112-L117">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.distMatrix" href="#GigaSOM.distMatrix"><code>GigaSOM.distMatrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">distMatrix(metric=Chebyshev())</code></pre><p>Return a function that uses the <code>metric</code> (compatible with metrics from package <code>Distances</code>) calculates distance matrixes from normal row-wise data matrices, using the <code>metric</code>.</p><p>Use as a parameter of <code>trainGigaSOM</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/7a0772a96800f58e6fcf9dce479eb83232aba375/src/base/trainutils.jl#L134-L140">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.expRadius" href="#GigaSOM.expRadius"><code>GigaSOM.expRadius</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">expRadius(steepness::Float64)</code></pre><p>Return a function to be used as a <code>radiusFun</code> of <code>trainGigaSOM</code>, which causes exponencial decay with the selected steepness.</p><p>Use: <code>trainGigaSOM(..., radiusFun = expRadius(0.5))</code></p><p><strong>Arguments</strong></p><ul><li><code>steepness</code>: Steepness of exponential descent. Good values range from -100.0 (almost linear) to 100.0 (really quick decay).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/7a0772a96800f58e6fcf9dce479eb83232aba375/src/base/trainutils.jl#L25-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.gaussianKernel-Tuple{Any, Float64}" href="#GigaSOM.gaussianKernel-Tuple{Any, Float64}"><code>GigaSOM.gaussianKernel</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">gaussianKernel(x, r::Float64)</code></pre><p>Return the value of normal distribution PDF (σ=<code>r</code>, μ=0) at <code>x</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/7a0772a96800f58e6fcf9dce479eb83232aba375/src/base/trainutils.jl#L93-L97">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.gridRectangular-Tuple{Any, Any}" href="#GigaSOM.gridRectangular-Tuple{Any, Any}"><code>GigaSOM.gridRectangular</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">gridRectangular(xdim, ydim)</code></pre><p>Create coordinates of all neurons on a rectangular SOM.</p><p>The return-value is an array of size (Number-of-neurons, 2) with x- and y- coordinates of the neurons in the first and second column respectively. The distance between neighbours is 1.0. The point of origin is bottom-left. The first neuron sits at (0,0).</p><p><strong>Arguments</strong></p><ul><li><code>xdim</code>: number of neurons in x-direction</li><li><code>ydim</code>: number of neurons in y-direction</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/7a0772a96800f58e6fcf9dce479eb83232aba375/src/base/trainutils.jl#L64-L79">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.linearRadius-Tuple{Float64, Float64, Int64, Int64}" href="#GigaSOM.linearRadius-Tuple{Float64, Float64, Int64, Int64}"><code>GigaSOM.linearRadius</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">linearRadius(initRadius::Float64, iteration::Int64, decay::String, epochs::Int64)</code></pre><p>Return a neighbourhood radius. Use as the <code>radiusFun</code> parameter for <code>trainGigaSOM</code>.</p><p><strong>Arguments</strong></p><ul><li><code>initRadius</code>: Initial Radius</li><li><code>finalRadius</code>: Final Radius</li><li><code>iteration</code>: Training iteration</li><li><code>epochs</code>: Total number of epochs</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/7a0772a96800f58e6fcf9dce479eb83232aba375/src/base/trainutils.jl#L2-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.thresholdKernel" href="#GigaSOM.thresholdKernel"><code>GigaSOM.thresholdKernel</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">thresholdKernel(x, r::Float64)</code></pre><p>Simple FlowSOM-like hard-threshold kernel</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/7a0772a96800f58e6fcf9dce479eb83232aba375/src/base/trainutils.jl#L122-L126">source</a></section></article><h2 id="Embedding"><a class="docs-heading-anchor" href="#Embedding">Embedding</a><a id="Embedding-1"></a><a class="docs-heading-anchor-permalink" href="#Embedding" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.embedGigaSOM-Tuple{Som, Any}" href="#GigaSOM.embedGigaSOM-Tuple{Som, Any}"><code>GigaSOM.embedGigaSOM</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">embedGigaSOM(som::GigaSOM.Som,
             data;
             knnTreeFun = BruteTree,
             metric = Euclidean(),
             k::Int64=0,
             adjust::Float64=1.0,
             smooth::Float64=0.0,
             m::Float64=10.0)</code></pre><p>Overload of <code>embedGigaSOM</code> for simple DataFrames and matrices. This slices the data using <code>DistributedArrays</code>, sends them the workers, and runs normal <code>embedGigaSOM</code>. All data is properly <code>undistribute</code>d after the computation.</p><p><strong>Examples:</strong></p><p>Produce a 2-column matrix with 2D cell coordinates:</p><pre><code class="nohighlight hljs">e = embedGigaSOM(som, data)</code></pre><p>Plot the result using 2D histogram from Gadfly:</p><pre><code class="nohighlight hljs">using Gadfly
draw(PNG(&quot;output.png&quot;,20cm,20cm),
     plot(x=e[:,1], y=e[:,2],
     Geom.histogram2d(xbincount=200, ybincount=200)))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/7a0772a96800f58e6fcf9dce479eb83232aba375/src/analysis/embedding.jl#L68-L96">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.embedGigaSOM-Tuple{Som, LoadedDataInfo}" href="#GigaSOM.embedGigaSOM-Tuple{Som, LoadedDataInfo}"><code>GigaSOM.embedGigaSOM</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">embedGigaSOM(som::GigaSOM.Som,
             dInfo::LoadedDataInfo;
             knnTreeFun = BruteTree,
             metric = Euclidean(),
             k::Int64=0,
             adjust::Float64=1.0,
             smooth::Float64=0.0,
             m::Float64=10.0,
             output::Symbol=tmpSym(dInfo))::LoadedDataInfo</code></pre><p>Return a data frame with X,Y coordinates of EmbedSOM projection of the data.</p><p><strong>Arguments:</strong></p><ul><li><code>som</code>: a trained SOM</li><li><code>dInfo</code>: <code>LoadedDataInfo</code> that describes the loaded dataset</li><li><code>knnTreeFun</code>: Constructor of the KNN-tree (e.g. from NearestNeighbors package)</li><li><code>metric</code>: Passed as metric argument to the KNN-tree constructor</li><li><code>k</code>: number of nearest neighbors to consider (high values get quadratically slower)</li><li><code>adjust</code>: position adjustment parameter (higher values avoid non-local approximations)</li><li><code>smooth</code>: approximation smoothness (the higher the value, the larger the neighborhood of approximate local linearity of the projection)</li><li><code>m</code>: exponential decay rate for the score when approaching the <code>k+1</code>-th neighbor distance</li><li><code>output</code>: variable name for storing the distributed result</li></ul><p>Data must have the same number of dimensions as the training dataset, and must be normalized using the same parameters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/7a0772a96800f58e6fcf9dce479eb83232aba375/src/analysis/embedding.jl#L1-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.embedGigaSOM_internal-Tuple{Som, Matrix{Float64}, Any, Int64, Float64, Float64, Float64}" href="#GigaSOM.embedGigaSOM_internal-Tuple{Som, Matrix{Float64}, Any, Int64, Float64, Float64, Float64}"><code>GigaSOM.embedGigaSOM_internal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">embedGigaSOM_internal(som::GigaSOM.Som,
                      data::Matrix{Float64},
                      tree,
                      k::Int64,
                      adjust::Float64,
                      boost::Float64,
                      m::Float64)</code></pre><p>Internal function to compute parts of the embedding on a prepared kNN-tree structure (<code>tree</code>) and <code>smooth</code> converted to <code>boost</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/7a0772a96800f58e6fcf9dce479eb83232aba375/src/analysis/embedding.jl#L127-L138">source</a></section></article><h2 id="Distributed-processing-tools"><a class="docs-heading-anchor" href="#Distributed-processing-tools">Distributed processing tools</a><a id="Distributed-processing-tools-1"></a><a class="docs-heading-anchor-permalink" href="#Distributed-processing-tools" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.distribute_array-Tuple{Symbol, Array, Any}" href="#GigaSOM.distribute_array-Tuple{Symbol, Array, Any}"><code>GigaSOM.distribute_array</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">distribute_array(sym, x::Array, pids; dim=1)::LoadedDataInfo</code></pre><p>Distribute roughly equal parts of array <code>x</code> separated on dimension <code>dim</code> among <code>pids</code> into a worker-local variable <code>sym</code>.</p><p>Returns the <code>LoadedDataInfo</code> structure for the distributed data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/7a0772a96800f58e6fcf9dce479eb83232aba375/src/base/distributed.jl#L70-L77">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.distribute_darray-Tuple{Symbol, DistributedArrays.DArray}" href="#GigaSOM.distribute_darray-Tuple{Symbol, DistributedArrays.DArray}"><code>GigaSOM.distribute_darray</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">distribute_darray(sym, dd::DArray)::LoadedDataInfo</code></pre><p>Distribute the distributed array parts from <code>dd</code> into worker-local variable <code>sym</code>.</p><p>Returns the <code>LoadedDataInfo</code> structure for the distributed data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/7a0772a96800f58e6fcf9dce479eb83232aba375/src/base/distributed.jl#L95-L102">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.distributed_collect" href="#GigaSOM.distributed_collect"><code>GigaSOM.distributed_collect</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">distributed_collect(dInfo::LoadedDataInfo, dim=1; free=false)</code></pre><p>Distributed collect (just as the other overload) that works with <code>LoadedDataInfo</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/7a0772a96800f58e6fcf9dce479eb83232aba375/src/base/distributed.jl#L314-L319">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.distributed_collect" href="#GigaSOM.distributed_collect"><code>GigaSOM.distributed_collect</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">distributed_collect(val::Symbol, workers, dim=1; free=false)</code></pre><p>Collect the arrays distributed on <code>workers</code> under value <code>val</code> into an array. The individual arrays are pasted in the dimension specified by <code>dim</code>, i.e. <code>dim=1</code> is roughly equivalent to using <code>vcat</code>, and <code>dim=2</code> to <code>hcat</code>.</p><p><code>val</code> must be an Array-based type; the function will otherwise fail.</p><p>If <code>free</code> is true, the <code>val</code> is undistributed after collection.</p><p>This preallocates the array for results, and is thus more efficient than e.g. using <code>distributed_mapreduce</code> with <code>vcat</code> for folding.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/7a0772a96800f58e6fcf9dce479eb83232aba375/src/base/distributed.jl#L280-L293">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.distributed_exec-Tuple{Any, Any, Any}" href="#GigaSOM.distributed_exec-Tuple{Any, Any, Any}"><code>GigaSOM.distributed_exec</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">distributed_exec(val, fn, workers)</code></pre><p>Execute a function on workers, taking <code>val</code> as a parameter. Results are not collected. This is optimal for various side-effect-causing computations that are not expressible with <code>distributed_transform</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/7a0772a96800f58e6fcf9dce479eb83232aba375/src/base/distributed.jl#L130-L136">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.distributed_exec-Tuple{LoadedDataInfo, Any}" href="#GigaSOM.distributed_exec-Tuple{LoadedDataInfo, Any}"><code>GigaSOM.distributed_exec</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">distributed_exec(dInfo::LoadedDataInfo, fn)</code></pre><p>Variant of <code>distributed_exec</code> that works with <code>LoadedDataInfo</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/7a0772a96800f58e6fcf9dce479eb83232aba375/src/base/distributed.jl#L148-L152">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.distributed_foreach-Tuple{Vector, Any, Any}" href="#GigaSOM.distributed_foreach-Tuple{Vector, Any, Any}"><code>GigaSOM.distributed_foreach</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">distributed_foreach(arr::Vector, fn, workers)</code></pre><p>Call a function <code>fn</code> on <code>workers</code>, with a single parameter arriving from the corresponding position in <code>arr</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/7a0772a96800f58e6fcf9dce479eb83232aba375/src/base/distributed.jl#L324-L329">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.distributed_mapreduce-NTuple{4, Any}" href="#GigaSOM.distributed_mapreduce-NTuple{4, Any}"><code>GigaSOM.distributed_mapreduce</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">distributed_mapreduce(val, map, fold, workers)</code></pre><p>Run <code>map</code>s (non-modifying transforms on the data) and <code>fold</code>s (2-to-1 reductions) on the worker-local data (in <code>val</code>s) distributed on <code>workers</code> and return the final reduced result.</p><p>It is assumed that the fold operation is associative, but not commutative (as in semigroups). If there are no workers, operation returns <code>nothing</code> (we don&#39;t have a monoid to magically conjure zero elements :[ ).</p><p>In current version, the reduce step is a sequential left fold, executed in the main process.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs"># compute the mean of all distributed data
sum,len = distributed_mapreduce(:myData,
    (d) -&gt; (sum(d),length(d)),
    ((s1, l1), (s2, l2)) -&gt; (s1+s2, l1+l2),
    workers())
println(sum/len)</code></pre><p><strong>Processing multiple arguments (a.k.a. &quot;zipWith&quot;)</strong></p><p>The <code>val</code> here does not necessarily need to refer to a symbol, you can easily pass in a quoted tuple, which will be unquoted in the function parameter. For example, distributed values <code>:a</code> and <code>:b</code> can be joined as such:</p><pre><code class="nohighlight hljs">distributed_mapreduce(:((a,b)),
    ((a,b)::Tuple) -&gt; [a b],
    vcat,
    workers())</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/7a0772a96800f58e6fcf9dce479eb83232aba375/src/base/distributed.jl#L188-L220">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.distributed_mapreduce-Tuple{LoadedDataInfo, Any, Any}" href="#GigaSOM.distributed_mapreduce-Tuple{LoadedDataInfo, Any, Any}"><code>GigaSOM.distributed_mapreduce</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">distributed_mapreduce(dInfo::LoadedDataInfo, map, fold)</code></pre><p>Distributed map/reduce (just as the other overload of <code>distributed_mapreduce</code>) that works with <code>LoadedDataInfo</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/7a0772a96800f58e6fcf9dce479eb83232aba375/src/base/distributed.jl#L240-L245">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.distributed_mapreduce-Tuple{Vector, Any, Any, Any}" href="#GigaSOM.distributed_mapreduce-Tuple{Vector, Any, Any, Any}"><code>GigaSOM.distributed_mapreduce</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">distributed_mapreduce(vals::Vector, map, fold, workers)</code></pre><p>Variant of <code>distributed_mapreduce</code> that works with more distributed variables at once.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/7a0772a96800f58e6fcf9dce479eb83232aba375/src/base/distributed.jl#L250-L255">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.distributed_mapreduce-Tuple{Vector{LoadedDataInfo}, Any, Any}" href="#GigaSOM.distributed_mapreduce-Tuple{Vector{LoadedDataInfo}, Any, Any}"><code>GigaSOM.distributed_mapreduce</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">distributed_mapreduce(dInfo1::LoadedDataInfo, dInfo2::LoadedDataInfo, map, fold)</code></pre><p>Variant of <code>distributed_mapreduce</code> that works with more <code>LoadedDataInfo</code>s at once.  The data must be distributed on the same set of workers, in the same order.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/7a0772a96800f58e6fcf9dce479eb83232aba375/src/base/distributed.jl#L260-L266">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.distributed_transform" href="#GigaSOM.distributed_transform"><code>GigaSOM.distributed_transform</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">distributed_transform(val, fn, workers, tgt::Symbol=val)</code></pre><p>Transform the worker-local distributed data available as <code>val</code> on <code>workers</code> in-place, by a function <code>fn</code>. Store the result as <code>tgt</code> (default <code>val</code>)</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs"># multiply all saved data by 2
distributed_transform(:myData, (d)-&gt;(2*d), workers())</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/7a0772a96800f58e6fcf9dce479eb83232aba375/src/base/distributed.jl#L157-L167">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.distributed_transform" href="#GigaSOM.distributed_transform"><code>GigaSOM.distributed_transform</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">distributed_transform(dInfo::LoadedDataInfo, fn, tgt::Symbol=dInfo.val)::LoadedDataInfo</code></pre><p>Same as <code>distributed_transform</code>, but specialized for <code>LoadedDataInfo</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/7a0772a96800f58e6fcf9dce479eb83232aba375/src/base/distributed.jl#L175-L179">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.get_from-Tuple{Any, Any}" href="#GigaSOM.get_from-Tuple{Any, Any}"><code>GigaSOM.get_from</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_from(worker,val)</code></pre><p>Get a value <code>val</code> from a remote <code>worker</code>; quoting of <code>val</code> works just as with <code>save_at</code>. Returns a future with the requested value.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/7a0772a96800f58e6fcf9dce479eb83232aba375/src/base/distributed.jl#L42-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.get_val_from-Tuple{Any, Any}" href="#GigaSOM.get_val_from-Tuple{Any, Any}"><code>GigaSOM.get_val_from</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_val_from(worker,val)</code></pre><p>Shortcut for instantly fetching the future from <code>get_from</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/7a0772a96800f58e6fcf9dce479eb83232aba375/src/base/distributed.jl#L52-L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.remove_from-Tuple{Any, Symbol}" href="#GigaSOM.remove_from-Tuple{Any, Symbol}"><code>GigaSOM.remove_from</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">remove_from(worker,sym)</code></pre><p>Sets symbol <code>sym</code> on <code>worker</code> to <code>nothing</code>, effectively freeing the data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/7a0772a96800f58e6fcf9dce479eb83232aba375/src/base/distributed.jl#L61-L65">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.save_at-Tuple{Any, Symbol, Any}" href="#GigaSOM.save_at-Tuple{Any, Symbol, Any}"><code>GigaSOM.save_at</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">save_at(worker, sym, val)</code></pre><p>Saves value <code>val</code> to symbol <code>sym</code> at <code>worker</code>. <code>sym</code> should be quoted (or contain a symbol). <code>val</code> gets unquoted in the processing and evaluated at the worker, quote it if you want to pass exact command to the worker.</p><p>This is loosely based on the package ParallelDataTransfers, but made slightly more flexible by omitting/delaying the explicit fetches etc. In particular, <code>save_at</code> is roughly the same as <code>ParallelDataTransfers.sendto</code>, and <code>get_val_from</code> works very much like <code>ParallelDataTransfers.getfrom</code>.</p><p><strong>Return value</strong></p><p>A future with Nothing that can be fetched to see that the operation has finished.</p><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">addprocs(1)
save_at(2,:x,123)       # saves 123
save_at(2,:x,myid())    # saves 1
save_at(2,:x,:(myid())) # saves 2
save_at(2,:x,:(:x))     # saves the symbol :x
                        # (just :x won&#39;t work because of unquoting)</code></pre><p><strong>Note: Symbol scope</strong></p><p>The symbols are saved in Main module on the corresponding worker. For example, <code>save_at(1, :x, nothing)</code> <em>will</em> erase your local <code>x</code> variable. Beware of name collisions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/7a0772a96800f58e6fcf9dce479eb83232aba375/src/base/distributed.jl#L1-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.tmpSym-Tuple{LoadedDataInfo}" href="#GigaSOM.tmpSym-Tuple{LoadedDataInfo}"><code>GigaSOM.tmpSym</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">tmpSym(dInfo::LoadedDataInfo; prefix=&quot;&quot;, suffix=&quot;_tmp&quot;)</code></pre><p>Decorate the symbol from <code>dInfo</code> with prefix and suffix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/7a0772a96800f58e6fcf9dce479eb83232aba375/src/base/distributed.jl#L348-L352">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.tmpSym-Tuple{Symbol}" href="#GigaSOM.tmpSym-Tuple{Symbol}"><code>GigaSOM.tmpSym</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">tmpSym(s::Symbol; prefix=&quot;&quot;, suffix=&quot;_tmp&quot;)</code></pre><p>Decorate a symbol <code>s</code> with prefix and suffix, to create a good name for a related temporary value.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/7a0772a96800f58e6fcf9dce479eb83232aba375/src/base/distributed.jl#L338-L343">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.undistribute-Tuple{LoadedDataInfo}" href="#GigaSOM.undistribute-Tuple{LoadedDataInfo}"><code>GigaSOM.undistribute</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">undistribute(dInfo::LoadedDataInfo)</code></pre><p>Remove the loaded data described by <code>dInfo</code> from the corresponding workers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/7a0772a96800f58e6fcf9dce479eb83232aba375/src/base/distributed.jl#L121-L125">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.undistribute-Tuple{Symbol, Any}" href="#GigaSOM.undistribute-Tuple{Symbol, Any}"><code>GigaSOM.undistribute</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">undistribute(sym, workers)</code></pre><p>Remove the loaded data from workers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/7a0772a96800f58e6fcf9dce479eb83232aba375/src/base/distributed.jl#L110-L114">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.defaultFiles-Tuple{Any, Any}" href="#GigaSOM.defaultFiles-Tuple{Any, Any}"><code>GigaSOM.defaultFiles</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">defaultFiles(s, pids)</code></pre><p>Make a good set of filenames for saving a dataset.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/7a0772a96800f58e6fcf9dce479eb83232aba375/src/io/dio.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.distributed_export" href="#GigaSOM.distributed_export"><code>GigaSOM.distributed_export</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">distributed_export(dInfo::LoadedDataInfo, files=defaultFiles(dInfo.val, dInfo.workers))</code></pre><p>Overloaded functionality for <code>LoadedDataInfo</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/7a0772a96800f58e6fcf9dce479eb83232aba375/src/io/dio.jl#L30-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.distributed_export" href="#GigaSOM.distributed_export"><code>GigaSOM.distributed_export</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">distributed_export(sym::Symbol, pids, files=defaultFiles(sym,pids))</code></pre><p>Export the content of symbol <code>sym</code> by each worker specified by <code>pids</code> to a corresponding filename in <code>files</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/7a0772a96800f58e6fcf9dce479eb83232aba375/src/io/dio.jl#L10-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.distributed_import" href="#GigaSOM.distributed_import"><code>GigaSOM.distributed_import</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">distributed_import(dInfo::LoadedDataInfo, files=defaultFiles(dInfo.val, dInfo.workers))</code></pre><p>Overloaded functionality for <code>LoadedDataInfo</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/7a0772a96800f58e6fcf9dce479eb83232aba375/src/io/dio.jl#L62-L66">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.distributed_import" href="#GigaSOM.distributed_import"><code>GigaSOM.distributed_import</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">distributed_import(sym::Symbol, pids, files=defaultFiles(sym,pids))</code></pre><p>Import the content of symbol <code>sym</code> by each worker specified by <code>pids</code> from the corresponding filename in <code>files</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/7a0772a96800f58e6fcf9dce479eb83232aba375/src/io/dio.jl#L42-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.distributed_unlink" href="#GigaSOM.distributed_unlink"><code>GigaSOM.distributed_unlink</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">distributed_unlink(dInfo::LoadedDataInfo, files=defaultFiles(dInfo.val, dInfo.workers))</code></pre><p>Overloaded functionality for <code>LoadedDataInfo</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/7a0772a96800f58e6fcf9dce479eb83232aba375/src/io/dio.jl#L84-L88">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.distributed_unlink" href="#GigaSOM.distributed_unlink"><code>GigaSOM.distributed_unlink</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">distributed_unlink(sym::Symbol, pids, files=defaultFiles(sym,pids))</code></pre><p>Remove the files created by <code>distributed_export</code> with the same parameters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/7a0772a96800f58e6fcf9dce479eb83232aba375/src/io/dio.jl#L74-L78">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../tutorials/whereToGoNext/">« Conclusion</a><a class="docs-footer-nextpage" href="../howToContribute/">How to contribute »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.12 on <span class="colophon-date" title="Wednesday 16 February 2022 12:52">Wednesday 16 February 2022</span>. Using Julia version 1.7.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
