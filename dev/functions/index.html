<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Functions · GigaSOM.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://lcsb-biocore.github.io/GigaSOM.jl/stable/functions/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/gigasomlogotransp.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="GigaSOM.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">GigaSOM.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../background/">Background</a></li><li><span class="tocitem">Tutorial</span><ul><li><a class="tocitem" href="../tutorials/basicUsage/">Introduction</a></li><li><a class="tocitem" href="../tutorials/processingFCSData/">Cytometry data</a></li><li><a class="tocitem" href="../tutorials/distributedProcessing/">Advanced distributed processing</a></li><li><a class="tocitem" href="../tutorials/whereToGoNext/">Conclusion</a></li></ul></li><li class="is-active"><a class="tocitem" href>Functions</a><ul class="internal"><li><a class="tocitem" href="#Data-structures"><span>Data structures</span></a></li><li><a class="tocitem" href="#Data-loading-and-preparation"><span>Data loading and preparation</span></a></li><li><a class="tocitem" href="#SOM-training"><span>SOM training</span></a></li><li><a class="tocitem" href="#Embedding"><span>Embedding</span></a></li></ul></li><li><a class="tocitem" href="../howToContribute/">How to contribute</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Functions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Functions</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/master/docs/src/functions.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Functions"><a class="docs-heading-anchor" href="#Functions">Functions</a><a id="Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Functions" title="Permalink"></a></h1><h2 id="Data-structures"><a class="docs-heading-anchor" href="#Data-structures">Data structures</a><a id="Data-structures-1"></a><a class="docs-heading-anchor-permalink" href="#Data-structures" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.Som" href="#GigaSOM.Som"><code>GigaSOM.Som</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Som</code></pre><p>Structure to hold all data of a trained SOM.</p><p><strong>Fields:</strong></p><ul><li><code>codes::Array{Float64,2}</code>: 2D-array of codebook vectors. One vector per row</li><li><code>xdim::Int</code>: number of neurons in x-direction</li><li><code>ydim::Int</code>: number of neurons in y-direction</li><li><code>numCodes::Int</code>: total number of neurons</li><li><code>grid::Array{Float64,2}</code>: 2D-array of coordinates of neurons on the map         (2 columns (x,y)] for rectangular and hexagonal maps          3 columns (x,y,z) for spherical maps)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/002dabd3a3988f41867945d51faabb56108ecba4/src/base/structs.jl#L1-L14">source</a></section></article><h2 id="Data-loading-and-preparation"><a class="docs-heading-anchor" href="#Data-loading-and-preparation">Data loading and preparation</a><a id="Data-loading-and-preparation-1"></a><a class="docs-heading-anchor-permalink" href="#Data-loading-and-preparation" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.distributeFCSFileVector" href="#GigaSOM.distributeFCSFileVector"><code>GigaSOM.distributeFCSFileVector</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">distributeFCSFileVector(name::Symbol, fns::Vector{String}, pids=workers())::Dinfo</code></pre><p>Distribute a vector of integers among the workers that describes which file from <code>fns</code> the cell comes from. Useful for producing per-file statistics. The vector is saved on workers specified by <code>pids</code> as a distributed variable <code>name</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/002dabd3a3988f41867945d51faabb56108ecba4/src/io/input.jl#L171-L178">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.distributeFileVector" href="#GigaSOM.distributeFileVector"><code>GigaSOM.distributeFileVector</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">distributeFileVector(name::Symbol, sizes::Vector{Int}, slices::Vector{Tuple{Int,Int,Int,Int}}, pids=workers())::Dinfo</code></pre><p>Generalized version of <code>distributeFCSFileVector</code> that produces the integer vector from any <code>sizes</code> and <code>slices</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/002dabd3a3988f41867945d51faabb56108ecba4/src/io/input.jl#L185-L190">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.getCSVSize-Tuple{String}" href="#GigaSOM.getCSVSize-Tuple{String}"><code>GigaSOM.getCSVSize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function getCSVSize(fn::String; args...)::Tuple{Int,Int}</code></pre><p>Read the dimensions (number of rows and columns, respectively) from a CSV file <code>fn</code>. <code>args</code> are passed to function <code>CSV.file</code>.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">getCSVSize(&quot;test.csv&quot;, header=false)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/002dabd3a3988f41867945d51faabb56108ecba4/src/io/input.jl#L206-L215">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.getFCSSize-Tuple{Any, Any}" href="#GigaSOM.getFCSSize-Tuple{Any, Any}"><code>GigaSOM.getFCSSize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getFCSSize(offsets, params)::Tuple{Int,Int}</code></pre><p>Convert the offsets and keywords from an FCS file to cell and parameter count, respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/002dabd3a3988f41867945d51faabb56108ecba4/src/io/input.jl#L15-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.loadCSV-Tuple{String}" href="#GigaSOM.loadCSV-Tuple{String}"><code>GigaSOM.loadCSV</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function loadCSV(fn::String; args...)::Matrix{Float64}</code></pre><p>CSV equivalent of <code>loadFCS</code>. The metadata (header, column names) are not extracted. <code>args</code> are passed to <code>CSV.read</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/002dabd3a3988f41867945d51faabb56108ecba4/src/io/input.jl#L239-L244">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.loadCSVSet" href="#GigaSOM.loadCSVSet"><code>GigaSOM.loadCSVSet</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">function loadCSVSet(
    name::Symbol,
    fns::Vector{String},
    pids = workers();
    postLoad = (d, i) -&gt; d,
    csvargs...,
)::Dinfo</code></pre><p>CSV equivalent of <code>loadFCSSet</code>. <code>csvargs</code> are passed as keyword arguments to CSV-loading functions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/002dabd3a3988f41867945d51faabb56108ecba4/src/io/input.jl#L249-L260">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.loadCSVSizes-Tuple{Vector{String}}" href="#GigaSOM.loadCSVSizes-Tuple{Vector{String}}"><code>GigaSOM.loadCSVSizes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function loadCSVSizes(fns::Vector{String}; args...)::Vector{Int}</code></pre><p>Determine number of rows in a list of CSV files (passed as <code>fns</code>). Equivalent to <code>loadFCSSizes</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/002dabd3a3988f41867945d51faabb56108ecba4/src/io/input.jl#L229-L234">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.loadFCS-Tuple{String}" href="#GigaSOM.loadFCS-Tuple{String}"><code>GigaSOM.loadFCS</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">loadFCS(fn::String; applyCompensation::Bool=true)::Tuple{Dict{String,String}, Matrix{Float64}}</code></pre><p>Read a FCS file. Return a tuple that contains in order:</p><ul><li>dictionary of the keywords contained in the file</li><li>raw column names</li><li>prettified and annotated column names</li><li>raw data matrix</li></ul><p>If <code>applyCompensation</code> is set, the function parses and retrieves a spillover matrix (if any valid keyword in the FCS is found that would contain it) and applies it to compensate the data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/002dabd3a3988f41867945d51faabb56108ecba4/src/io/input.jl#L62-L75">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.loadFCSHeader-Tuple{String}" href="#GigaSOM.loadFCSHeader-Tuple{String}"><code>GigaSOM.loadFCSHeader</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">loadFCSHeader(fn::String)::Tuple{Vector{Int}, Dict{String,String}}</code></pre><p>Efficiently extract data offsets and keyword dictionary from an FCS file.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/002dabd3a3988f41867945d51faabb56108ecba4/src/io/input.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.loadFCSSet" href="#GigaSOM.loadFCSSet"><code>GigaSOM.loadFCSSet</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">loadFCSSet(name::Symbol, fns::Vector{String}, pids=workers(); applyCompensation=true, postLoad=(d,i)-&gt;d)::Dinfo</code></pre><p>This runs the FCS loading machinery in a distributed way, so that the files <code>fns</code> (with full path) are sliced into equal parts and saved as a distributed variable <code>name</code> on workers specified by <code>pids</code>.</p><p><code>applyCompensation</code> is passed to loadFCS function.</p><p>See <code>slicesof</code> for description of the slicing.</p><p><code>postLoad</code> is applied to the loaded FCS file data (and the index) – use this function to e.g. filter out certain columns right on loading, using <code>selectFCSColumns</code>.</p><p>The loaded dataset can be manipulated by the distributed functions, e.g.</p><ul><li><code>dselect</code> for removing columns</li><li><code>dscale</code> for normalization</li><li><code>dtransform_asinh</code> (and others) for transformation</li><li>etc.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/002dabd3a3988f41867945d51faabb56108ecba4/src/io/input.jl#L98-L117">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.loadFCSSizes-Tuple{Vector{String}}" href="#GigaSOM.loadFCSSizes-Tuple{Vector{String}}"><code>GigaSOM.loadFCSSizes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">loadFCSSizes(fns::Vector{String})</code></pre><p>Load cell counts in many FCS files at once. Useful as input for <code>slicesof</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/002dabd3a3988f41867945d51faabb56108ecba4/src/io/input.jl#L48-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.selectFCSColumns-Tuple{Vector{String}}" href="#GigaSOM.selectFCSColumns-Tuple{Vector{String}}"><code>GigaSOM.selectFCSColumns</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">selectFCSColumns(selectColnames::Vector{String})</code></pre><p>Return a function useful with <code>loadFCSSet</code>, which loads only the specified (prettified) column names from the FCS files. Use <code>getMetaData</code>, <code>getMarkerNames</code> and <code>cleanNames!</code> to retrieve the usable column names for a FCS.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/002dabd3a3988f41867945d51faabb56108ecba4/src/io/input.jl#L150-L157">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.cleanNames!-Tuple{Vector{String}}" href="#GigaSOM.cleanNames!-Tuple{Vector{String}}"><code>GigaSOM.cleanNames!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cleanNames!(mydata::Vector{String})</code></pre><p>Replaces problematic characters in column names, avoids duplicate names, and prefixes an &#39;_&#39; if the name starts with a number.</p><p><strong>Arguments:</strong></p><ul><li><code>mydata</code>: vector of names (gets modified)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/002dabd3a3988f41867945d51faabb56108ecba4/src/io/process.jl#L1-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.compensate!-Tuple{Matrix{Float64}, Matrix{Float64}, Vector{Int64}}" href="#GigaSOM.compensate!-Tuple{Matrix{Float64}, Matrix{Float64}, Vector{Int64}}"><code>GigaSOM.compensate!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">compensate!(data::Matrix{Float64}, spillover::Matrix{Float64}, cols::Vector{Int})</code></pre><p>Apply a compensation matrix in <code>spillover</code> (the individual columns of which describe, in order, the spillover of <code>cols</code> in <code>data</code>) to the matrix <code>data</code> in-place.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/002dabd3a3988f41867945d51faabb56108ecba4/src/io/process.jl#L101-L107">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.getMarkerNames-Tuple{DataFrames.DataFrame}" href="#GigaSOM.getMarkerNames-Tuple{DataFrames.DataFrame}"><code>GigaSOM.getMarkerNames</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getMarkerNames(meta::DataFrame)::Tuple{Vector{String}, Vector{String}}</code></pre><p>Extract suitable raw names (useful for selecting columns) and pretty readable names (useful for humans) from FCS file metadata.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/002dabd3a3988f41867945d51faabb56108ecba4/src/io/process.jl#L80-L86">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.getMetaData-Tuple{Dict{String, String}}" href="#GigaSOM.getMetaData-Tuple{Dict{String, String}}"><code>GigaSOM.getMetaData</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getMetaData(f)</code></pre><p>Collect the meta data information in a more user friendly format.</p><p><strong>Arguments:</strong></p><ul><li><code>f</code>: input structure with <code>.params</code> and <code>.data</code> fields</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/002dabd3a3988f41867945d51faabb56108ecba4/src/io/process.jl#L32-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.getSpillover-Tuple{Dict{String, String}}" href="#GigaSOM.getSpillover-Tuple{Dict{String, String}}"><code>GigaSOM.getSpillover</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getSpillover(params::Dict{String, String})::Union{Tuple{Vector{String},Matrix{Float64}}, Nothing}</code></pre><p>Get a spillover matrix from FCS <code>params</code>. Returns a pair with description of columns to be applied, and with the actual spillover matrix. Returns <code>nothing</code> in case spillover is not present.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/002dabd3a3988f41867945d51faabb56108ecba4/src/io/process.jl#L131-L137">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.parseSpillover-Tuple{String}" href="#GigaSOM.parseSpillover-Tuple{String}"><code>GigaSOM.parseSpillover</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">parseSpillover(str::String)::Union{Tuple{Vector{String},Matrix{Float64}}, Nothing}</code></pre><p>Parses the spillover matrix from the string from FCS parameter value.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/002dabd3a3988f41867945d51faabb56108ecba4/src/io/process.jl#L112-L116">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.collectSlice-Tuple{Any, NTuple{4, Int64}}" href="#GigaSOM.collectSlice-Tuple{Any, NTuple{4, Int64}}"><code>GigaSOM.collectSlice</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">collectSlice(loadVec, (startFile, startOff, finalFile, finalOff)::Tuple{Int,Int,Int,Int})::Vector</code></pre><p>Alternative of <code>vcollectSlice</code> for 1D vectors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/002dabd3a3988f41867945d51faabb56108ecba4/src/io/splitting.jl#L94-L98">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.slicesof-Tuple{Vector{Int64}, Int64}" href="#GigaSOM.slicesof-Tuple{Vector{Int64}, Int64}"><code>GigaSOM.slicesof</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">slicesof(lengths::Vector{Int}, slices::Int)::Vector{Tuple{Int,Int,Int,Int}}</code></pre><p>Given a list of <code>lengths</code> of input arrays, compute a slicing into a specified amount of equally-sized <code>slices</code>.</p><p>The output is a vector of 4-tuples where each specifies how to create one slice. The i-th tuple field contains, in order:</p><ul><li>the index of input array at which the i-th slice begins</li><li>first element of the i-th slice in that input array</li><li>the index of input array with the last element of the i-th slice</li><li>the index of the last element of the i-th slice in that array</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/002dabd3a3988f41867945d51faabb56108ecba4/src/io/splitting.jl#L1-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.vcollectSlice-Tuple{Any, NTuple{4, Int64}}" href="#GigaSOM.vcollectSlice-Tuple{Any, NTuple{4, Int64}}"><code>GigaSOM.vcollectSlice</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">vcollectSlice(loadMtx, (startFile, startOff, finalFile, finalOff)::Tuple{Int,Int,Int,Int})::Matrix</code></pre><p>Given a method to obtain matrix content (<code>loadMtx</code>), reconstruct a slice from the information generated by <code>slicesof</code>.</p><p>This function is specialized for reconstructing matrices and arrays, where the &quot;element counts&quot; split by <code>slicesof</code> are in fact matrix rows. The function is therefore named <em>v</em>collect (the slicing and concatenation is <em>v</em>ertical).</p><p>The actual data content and loading method is abstracted out – function <code>loadMtx</code> gets the index of the input part that it is required to fetch (e.g. index of one FCS file), and is expected to return that input part as a whole matrix. <code>vcollectSlice</code> correctly calls this function as required and extracts relevant portions of the matrices, so that at the end the whole slice can be pasted together.</p><p>Example:</p><pre><code class="nohighlight hljs"># get a list of files
filenames=[&quot;a.fcs&quot;, &quot;b.fcs&quot;]
# get descriptions of 5 equally sized parts of the data
slices = slicesof(loadFCSSizes(filenames), 5)

# reconstruct first 3 columns of the first slice
mySlice = vcollectSlice(
    i -&gt; last(loadFCS(slices[i]))[:,1:3],
    slices[1])
# (note: function loadFCS returns 4 items, the matrix is the last one)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/002dabd3a3988f41867945d51faabb56108ecba4/src/io/splitting.jl#L48-L77">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.dtransform_asinh" href="#GigaSOM.dtransform_asinh"><code>GigaSOM.dtransform_asinh</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">dtransform_asinh(dInfo::Dinfo, columns::Vector{Int}, cofactor=5)</code></pre><p>Transform columns of the dataset by asinh transformation with <code>cofactor</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/002dabd3a3988f41867945d51faabb56108ecba4/src/base/dataops.jl#L1-L5">source</a></section></article><h2 id="SOM-training"><a class="docs-heading-anchor" href="#SOM-training">SOM training</a><a id="SOM-training-1"></a><a class="docs-heading-anchor-permalink" href="#SOM-training" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.distributedEpoch-Tuple{DistributedData.Dinfo, Matrix{Float64}, Any}" href="#GigaSOM.distributedEpoch-Tuple{DistributedData.Dinfo, Matrix{Float64}, Any}"><code>GigaSOM.distributedEpoch</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">distributedEpoch(dInfo::Dinfo, codes::Matrix{Float64}, tree)</code></pre><p>Execute the <code>doEpoch</code> in parallel on workers described by <code>dInfo</code> and collect the results. Returns pair of numerator and denominator matrices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/002dabd3a3988f41867945d51faabb56108ecba4/src/analysis/core.jl#L217-L222">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.doEpoch-Tuple{Matrix{Float64}, Matrix{Float64}, Any}" href="#GigaSOM.doEpoch-Tuple{Matrix{Float64}, Matrix{Float64}, Any}"><code>GigaSOM.doEpoch</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">doEpoch(x::Array{Float64, 2}, codes::Array{Float64, 2}, tree)</code></pre><p>vectors and the adjustment in radius after each epoch.</p><p><strong>Arguments:</strong></p><ul><li><code>x</code>: training Data</li><li><code>codes</code>: Codebook</li><li><code>tree</code>: knn-compatible tree built upon the codes</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/002dabd3a3988f41867945d51faabb56108ecba4/src/analysis/core.jl#L188-L197">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.initGigaSOM" href="#GigaSOM.initGigaSOM"><code>GigaSOM.initGigaSOM</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">function initGigaSOM(ncol::Int64,
                     means::Vector{Float64}, sdevs::Vector{Float64},
                     xdim::Int64, ydim::Int64 = xdim;
                     seed = rand(Int), rng = StableRNG(seed))</code></pre><p>Generate a stable random initial SOM with the random distribution that matches the parameters.</p><p>Arguments:</p><ul><li><code>ncol</code>: number of desired data columns</li><li><code>means</code>, <code>sdevs</code>: vectors that describe the data distribution, both of size <code>ncol</code></li><li><code>xdim</code>, <code>ydim</code>: Size of the SOM</li><li><code>seed</code>: a seed (defaults to random seed from the current default random generator</li><li><code>rng</code>: a random number generator to be used (defaults to a <code>StableRNG</code> initialized with the <code>seed</code>)</li></ul><p>Returns: a new <code>Som</code> structure</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/002dabd3a3988f41867945d51faabb56108ecba4/src/analysis/core.jl#L42-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.initGigaSOM-Tuple{DistributedData.Dinfo, Vararg{Any}}" href="#GigaSOM.initGigaSOM-Tuple{DistributedData.Dinfo, Vararg{Any}}"><code>GigaSOM.initGigaSOM</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function initGigaSOM(data::Dinfo,
                     xdim::Int64, ydim::Int64 = xdim;
                     seed=rand(Int), rng=StableRNG(seed))</code></pre><p><code>initGigaSOM</code> overload for working with distributed-style <code>Dinfo</code> data. The rest of the arguments is passed to the data-independent <code>initGigaSOM</code>.</p><p>Arguments:</p><ul><li><code>data</code>: a <code>Dinfo</code> object with the distributed dataset matrix</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/002dabd3a3988f41867945d51faabb56108ecba4/src/analysis/core.jl#L23-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.initGigaSOM-Tuple{Union{DataFrames.DataFrame, Matrix}, Vararg{Any}}" href="#GigaSOM.initGigaSOM-Tuple{Union{DataFrames.DataFrame, Matrix}, Vararg{Any}}"><code>GigaSOM.initGigaSOM</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initGigaSOM(data, args...)</code></pre><p>Initializes a SOM by random selection from the training data. A generic overload that works for matrices and DataFrames that can be coerced to <code>Matrix{Float64}</code>. Other arguments are passed to the data-independent <code>initGigaSOM</code>.</p><p>Arguments:</p><ul><li><code>data</code>: matrix of data for running the initialization</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/002dabd3a3988f41867945d51faabb56108ecba4/src/analysis/core.jl#L1-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.mapToGigaSOM-Tuple{Som, Any}" href="#GigaSOM.mapToGigaSOM-Tuple{Som, Any}"><code>GigaSOM.mapToGigaSOM</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mapToGigaSOM(som::Som, data;
             knnTreeFun = BruteTree,
             metric = Euclidean())</code></pre><p>Overload of <code>mapToGigaSOM</code> for simple DataFrames and matrices. This slices the data using <code>DistributedArrays</code>, sends them the workers, and runs normal <code>mapToGigaSOM</code>. Data is <code>unscatter</code>d after the computation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/002dabd3a3988f41867945d51faabb56108ecba4/src/analysis/core.jl#L262-L269">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.mapToGigaSOM-Tuple{Som, DistributedData.Dinfo}" href="#GigaSOM.mapToGigaSOM-Tuple{Som, DistributedData.Dinfo}"><code>GigaSOM.mapToGigaSOM</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mapToGigaSOM(som::Som, dInfo::Dinfo;
    knnTreeFun = BruteTree, metric = Euclidean(),
    output::Symbol=tmp_symbol(dInfo)::Dinfo</code></pre><p>Compute the index of the BMU for each row of the input data.</p><p><strong>Arguments</strong></p><ul><li><code>som</code>: a trained SOM</li><li><code>dInfo</code>: <code>Dinfo</code> that describes the loaded and distributed data</li><li><code>knnTreeFun</code>: Constructor of the KNN-tree (e.g. from NearestNeighbors package)</li><li><code>metric</code>: Passed as metric argument to the KNN-tree constructor</li><li><code>output</code>: Symbol to save the result, defaults to <code>tmp_symbol(dInfo)</code></li></ul><p>Data must have the same number of dimensions as the training dataset and will be normalised with the same parameters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/002dabd3a3988f41867945d51faabb56108ecba4/src/analysis/core.jl#L232-L248">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.scaleEpochTime-Tuple{Int64, Int64}" href="#GigaSOM.scaleEpochTime-Tuple{Int64, Int64}"><code>GigaSOM.scaleEpochTime</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">scaleEpochTime(iteration::Int64, epochs::Int64)</code></pre><p>Convert iteration ID and epoch number to relative time in training.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/002dabd3a3988f41867945d51faabb56108ecba4/src/analysis/core.jl#L287-L291">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.trainGigaSOM-Tuple{Som, Any}" href="#GigaSOM.trainGigaSOM-Tuple{Som, Any}"><code>GigaSOM.trainGigaSOM</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">trainGigaSOM(som::Som, train;
             kwargs...)</code></pre><p>Overload of <code>trainGigaSOM</code> for simple DataFrames and matrices. This slices the data, distributes them to the workers, and runs normal <code>trainGigaSOM</code>. Data is <code>unscatter</code>d after the computation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/002dabd3a3988f41867945d51faabb56108ecba4/src/analysis/core.jl#L168-L175">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.trainGigaSOM-Tuple{Som, DistributedData.Dinfo}" href="#GigaSOM.trainGigaSOM-Tuple{Som, DistributedData.Dinfo}"><code>GigaSOM.trainGigaSOM</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">trainGigaSOM(
    som::Som,
    dInfo::Dinfo;
    kernelFun::Function = gaussianKernel,
    metric = Euclidean(),
    somDistFun = distMatrix(Chebyshev()),
    knnTreeFun = BruteTree,
    rStart = 0.0,
    rFinal = 0.1,
    radiusFun = expRadius(-5.0),
    epochs = 20,
    eachEpoch = (e, r, som) -&gt; nothing,
)</code></pre><p><strong>Arguments:</strong></p><ul><li><code>som</code>: object of type Som with an initialised som</li><li><code>dInfo</code>: <code>Dinfo</code> object that describes a loaded dataset</li><li><code>kernelFun::function</code>: optional distance kernel; one of (<code>bubbleKernel, gaussianKernel</code>)           default is <code>gaussianKernel</code></li><li><code>metric</code>: Passed as metric argument to the KNN-tree constructor</li><li><code>somDistFun</code>: Function for computing the distances in the SOM map</li><li><code>knnTreeFun</code>: Constructor of the KNN-tree (e.g. from NearestNeighbors package)</li><li><code>rStart</code>: optional training radius. If zero (default), it is computed from the SOM grid size.</li><li><code>rFinal</code>: target radius at the last epoch, defaults to 0.1</li><li><code>radiusFun</code>: Function that generates radius decay, e.g. <code>linearRadius</code> or <code>expRadius(10.0)</code></li><li><code>epochs</code>: number of SOM training iterations (default 10)</li><li><code>eachEpoch</code>: a function to call back after each epoch, accepting arguments <code>(epochNumber, radius, som)</code>. For simplicity, this gets additionally called once before the first epoch, with <code>epochNumber</code> set to zero.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/002dabd3a3988f41867945d51faabb56108ecba4/src/analysis/core.jl#L84-L114">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.bubbleKernel-Tuple{Any, Float64}" href="#GigaSOM.bubbleKernel-Tuple{Any, Float64}"><code>GigaSOM.bubbleKernel</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">bubbleKernel(x, r::Float64)</code></pre><p>Return a &quot;bubble&quot; (spherical) distribution kernel.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/002dabd3a3988f41867945d51faabb56108ecba4/src/base/trainutils.jl#L114-L119">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.distMatrix" href="#GigaSOM.distMatrix"><code>GigaSOM.distMatrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">distMatrix(metric=Chebyshev())</code></pre><p>Return a function that uses the <code>metric</code> (compatible with metrics from package <code>Distances</code>) calculates distance matrixes from normal row-wise data matrices, using the <code>metric</code>.</p><p>Use as a parameter of <code>trainGigaSOM</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/002dabd3a3988f41867945d51faabb56108ecba4/src/base/trainutils.jl#L136-L142">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.expRadius" href="#GigaSOM.expRadius"><code>GigaSOM.expRadius</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">expRadius(steepness::Float64)</code></pre><p>Return a function to be used as a <code>radiusFun</code> of <code>trainGigaSOM</code>, which causes exponencial decay with the selected steepness.</p><p>Use: <code>trainGigaSOM(..., radiusFun = expRadius(0.5))</code></p><p><strong>Arguments</strong></p><ul><li><code>steepness</code>: Steepness of exponential descent. Good values range from -100.0 (almost linear) to 100.0 (really quick decay).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/002dabd3a3988f41867945d51faabb56108ecba4/src/base/trainutils.jl#L25-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.gaussianKernel-Tuple{Any, Float64}" href="#GigaSOM.gaussianKernel-Tuple{Any, Float64}"><code>GigaSOM.gaussianKernel</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">gaussianKernel(x, r::Float64)</code></pre><p>Return the value of normal distribution PDF (σ=<code>r</code>, μ=0) at <code>x</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/002dabd3a3988f41867945d51faabb56108ecba4/src/base/trainutils.jl#L95-L99">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.gridRectangular-Tuple{Any, Any}" href="#GigaSOM.gridRectangular-Tuple{Any, Any}"><code>GigaSOM.gridRectangular</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">gridRectangular(xdim, ydim)</code></pre><p>Create coordinates of all neurons on a rectangular SOM.</p><p>The return-value is an array of size (Number-of-neurons, 2) with x- and y- coordinates of the neurons in the first and second column respectively. The distance between neighbours is 1.0. The point of origin is bottom-left. The first neuron sits at (0,0).</p><p><strong>Arguments</strong></p><ul><li><code>xdim</code>: number of neurons in x-direction</li><li><code>ydim</code>: number of neurons in y-direction</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/002dabd3a3988f41867945d51faabb56108ecba4/src/base/trainutils.jl#L66-L81">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.linearRadius-Tuple{Float64, Float64, Int64, Int64}" href="#GigaSOM.linearRadius-Tuple{Float64, Float64, Int64, Int64}"><code>GigaSOM.linearRadius</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">linearRadius(initRadius::Float64, iteration::Int64, decay::String, epochs::Int64)</code></pre><p>Return a neighbourhood radius. Use as the <code>radiusFun</code> parameter for <code>trainGigaSOM</code>.</p><p><strong>Arguments</strong></p><ul><li><code>initRadius</code>: Initial Radius</li><li><code>finalRadius</code>: Final Radius</li><li><code>iteration</code>: Training iteration</li><li><code>epochs</code>: Total number of epochs</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/002dabd3a3988f41867945d51faabb56108ecba4/src/base/trainutils.jl#L2-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.thresholdKernel" href="#GigaSOM.thresholdKernel"><code>GigaSOM.thresholdKernel</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">thresholdKernel(x, r::Float64)</code></pre><p>Simple FlowSOM-like hard-threshold kernel</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/002dabd3a3988f41867945d51faabb56108ecba4/src/base/trainutils.jl#L124-L128">source</a></section></article><h2 id="Embedding"><a class="docs-heading-anchor" href="#Embedding">Embedding</a><a id="Embedding-1"></a><a class="docs-heading-anchor-permalink" href="#Embedding" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.embedGigaSOM-Tuple{Som, Any}" href="#GigaSOM.embedGigaSOM-Tuple{Som, Any}"><code>GigaSOM.embedGigaSOM</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">embedGigaSOM(som::GigaSOM.Som,
             data;
             knnTreeFun = BruteTree,
             metric = Euclidean(),
             k::Int64=0,
             adjust::Float64=1.0,
             smooth::Float64=0.0,
             m::Float64=10.0)</code></pre><p>Overload of <code>embedGigaSOM</code> for simple DataFrames and matrices. This slices the data using <code>DistributedArrays</code>, sends them the workers, and runs normal <code>embedGigaSOM</code>. All data is properly <code>unscatter</code>d after the computation.</p><p><strong>Examples:</strong></p><p>Produce a 2-column matrix with 2D cell coordinates:</p><pre><code class="nohighlight hljs">e = embedGigaSOM(som, data)</code></pre><p>Plot the result using 2D histogram from Gadfly:</p><pre><code class="nohighlight hljs">using Gadfly
draw(PNG(&quot;output.png&quot;,20cm,20cm),
     plot(x=e[:,1], y=e[:,2],
     Geom.histogram2d(xbincount=200, ybincount=200)))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/002dabd3a3988f41867945d51faabb56108ecba4/src/analysis/embedding.jl#L68-L96">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.embedGigaSOM-Tuple{Som, DistributedData.Dinfo}" href="#GigaSOM.embedGigaSOM-Tuple{Som, DistributedData.Dinfo}"><code>GigaSOM.embedGigaSOM</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">embedGigaSOM(som::GigaSOM.Som,
             dInfo::Dinfo;
             knnTreeFun = BruteTree,
             metric = Euclidean(),
             k::Int64=0,
             adjust::Float64=1.0,
             smooth::Float64=0.0,
             m::Float64=10.0,
             output::Symbol=tmp_symbol(dInfo))::Dinfo</code></pre><p>Return a data frame with X,Y coordinates of EmbedSOM projection of the data.</p><p><strong>Arguments:</strong></p><ul><li><code>som</code>: a trained SOM</li><li><code>dInfo</code>: <code>Dinfo</code> that describes the loaded dataset</li><li><code>knnTreeFun</code>: Constructor of the KNN-tree (e.g. from NearestNeighbors package)</li><li><code>metric</code>: Passed as metric argument to the KNN-tree constructor</li><li><code>k</code>: number of nearest neighbors to consider (high values get quadratically slower)</li><li><code>adjust</code>: position adjustment parameter (higher values avoid non-local approximations)</li><li><code>smooth</code>: approximation smoothness (the higher the value, the larger the neighborhood of approximate local linearity of the projection)</li><li><code>m</code>: exponential decay rate for the score when approaching the <code>k+1</code>-th neighbor distance</li><li><code>output</code>: variable name for storing the distributed result</li></ul><p>Data must have the same number of dimensions as the training dataset, and must be normalized using the same parameters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/002dabd3a3988f41867945d51faabb56108ecba4/src/analysis/embedding.jl#L1-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.embedGigaSOM_internal-Tuple{Som, Matrix{Float64}, Any, Int64, Float64, Float64, Float64}" href="#GigaSOM.embedGigaSOM_internal-Tuple{Som, Matrix{Float64}, Any, Int64, Float64, Float64, Float64}"><code>GigaSOM.embedGigaSOM_internal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">embedGigaSOM_internal(som::GigaSOM.Som,
                      data::Matrix{Float64},
                      tree,
                      k::Int64,
                      adjust::Float64,
                      boost::Float64,
                      m::Float64)</code></pre><p>Internal function to compute parts of the embedding on a prepared kNN-tree structure (<code>tree</code>) and <code>smooth</code> converted to <code>boost</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/002dabd3a3988f41867945d51faabb56108ecba4/src/analysis/embedding.jl#L127-L138">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../tutorials/whereToGoNext/">« Conclusion</a><a class="docs-footer-nextpage" href="../howToContribute/">How to contribute »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Tuesday 30 August 2022 06:54">Tuesday 30 August 2022</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
