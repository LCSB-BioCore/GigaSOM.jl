<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Functions · GigaSOM.jl</title><link rel="canonical" href="https://lcsb-biocore.github.io/GigaSOM.jl/stable/functions/"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/gigasomlogotransp.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="GigaSOM.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">GigaSOM.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../background/">Background</a></li><li><span class="tocitem">Tutorial</span><ul><li><a class="tocitem" href="../tutorials/basicUsage/">Introduction</a></li><li><a class="tocitem" href="../tutorials/processingFCSData/">Cytometry data</a></li><li><a class="tocitem" href="../tutorials/distributedProcessing/">Advanced distributed processing</a></li><li><a class="tocitem" href="../tutorials/whereToGoNext/">Conclusion</a></li></ul></li><li class="is-active"><a class="tocitem" href>Functions</a><ul class="internal"><li><a class="tocitem" href="#Data-structures"><span>Data structures</span></a></li><li><a class="tocitem" href="#Data-loading-and-preparation"><span>Data loading and preparation</span></a></li><li><a class="tocitem" href="#SOM-training"><span>SOM training</span></a></li><li><a class="tocitem" href="#Embedding"><span>Embedding</span></a></li><li><a class="tocitem" href="#Distributed-processing-tools"><span>Distributed processing tools</span></a></li></ul></li><li><a class="tocitem" href="../howToContribute/">How to contribute</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Functions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Functions</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/master/docs/src/functions.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Functions"><a class="docs-heading-anchor" href="#Functions">Functions</a><a id="Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Functions" title="Permalink"></a></h1><h2 id="Data-structures"><a class="docs-heading-anchor" href="#Data-structures">Data structures</a><a id="Data-structures-1"></a><a class="docs-heading-anchor-permalink" href="#Data-structures" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.LoadedDataInfo" href="#GigaSOM.LoadedDataInfo"><code>GigaSOM.LoadedDataInfo</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">LoadedDataInfo</code></pre><p>The basic structure for working with loaded data, distributed amongst workers. In completeness, it represents a dataset as such:</p><ul><li><code>val</code> is the &quot;value name&quot; under which the data are saved in processes. E.g. <code>val=:foo</code> means that there is a variable <code>foo</code> on each process holding a part of the matrix.</li><li><code>workers</code> is a list of workers (in correct order!) that hold the data (similar to <code>DArray.pids</code>)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/741568d3a3448e2d52b55deb401e3f15517994d1/src/base/structs.jl#L34-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.Som" href="#GigaSOM.Som"><code>GigaSOM.Som</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Som</code></pre><p>Structure to hold all data of a trained SOM.</p><p><strong>Fields:</strong></p><ul><li><code>codes::Array{Float64,2}</code>: 2D-array of codebook vectors. One vector per row</li><li><code>colNames::Array{String,1}</code>: names of the attribute with which the SOM is trained</li><li><code>xdim::Int</code>: number of neurons in x-direction</li><li><code>ydim::Int</code>: number of neurons in y-direction</li><li><code>numCodes::Int</code>: total number of neurons</li><li><code>grid::Array{Float64,2}</code>: 2D-array of coordinates of neurons on the map         (2 columns (x,y)] for rectangular and hexagonal maps          3 columns (x,y,z) for spherical maps)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/741568d3a3448e2d52b55deb401e3f15517994d1/src/base/structs.jl#L1-L15">source</a></section></article><h2 id="Data-loading-and-preparation"><a class="docs-heading-anchor" href="#Data-loading-and-preparation">Data loading and preparation</a><a id="Data-loading-and-preparation-1"></a><a class="docs-heading-anchor-permalink" href="#Data-loading-and-preparation" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.distributeFCSFileVector" href="#GigaSOM.distributeFCSFileVector"><code>GigaSOM.distributeFCSFileVector</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">distributeFCSFileVector(name::Symbol, fns::Vector{String}, pids=workers())::LoadedDataInfo</code></pre><p>Distribute a vector of integers among the workers that describes which file from <code>fns</code> the cell comes from. Useful for producing per-file statistics. The vector is saved on workers specified by <code>pids</code> as a distributed variable <code>name</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/741568d3a3448e2d52b55deb401e3f15517994d1/src/io/input.jl#L169-L176">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.distributeFileVector" href="#GigaSOM.distributeFileVector"><code>GigaSOM.distributeFileVector</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">distributeFileVector(name::Symbol, sizes::Vector{Int}, slices::Vector{Tuple{Int,Int,Int,Int}}, pids=workers())::LoadedDataInfo</code></pre><p>Generalized version of <code>distributeFCSFileVector</code> that produces the integer vector from any <code>sizes</code> and <code>slices</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/741568d3a3448e2d52b55deb401e3f15517994d1/src/io/input.jl#L187-L192">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.getFCSSize-Tuple{Any,Any}" href="#GigaSOM.getFCSSize-Tuple{Any,Any}"><code>GigaSOM.getFCSSize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">getFCSSize(offsets, params)::Tuple{Int,Int}</code></pre><p>Convert the offsets and keywords from an FCS file to cell and parameter count, respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/741568d3a3448e2d52b55deb401e3f15517994d1/src/io/input.jl#L15-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.loadFCS-Tuple{String}" href="#GigaSOM.loadFCS-Tuple{String}"><code>GigaSOM.loadFCS</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">loadFCS(fn::String; applyCompensation::Bool=true)::Tuple{Dict{String,String}, Matrix{Float64}}</code></pre><p>Read a FCS file. Return a tuple that contains in order:</p><ul><li>dictionary of the keywords contained in the file</li><li>raw column names</li><li>prettified and annotated column names</li><li>raw data matrix</li></ul><p>If <code>applyCompensation</code> is set, the function parses and retrieves a spillover matrix (if any valid keyword in the FCS is found that would contain it) and applies it to compensate the data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/741568d3a3448e2d52b55deb401e3f15517994d1/src/io/input.jl#L62-L75">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.loadFCSHeader-Tuple{String}" href="#GigaSOM.loadFCSHeader-Tuple{String}"><code>GigaSOM.loadFCSHeader</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">loadFCSHeader(fn::String)::Tuple{Vector{Int}, Dict{String,String}}</code></pre><p>Efficiently extract data offsets and keyword dictionary from an FCS file.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/741568d3a3448e2d52b55deb401e3f15517994d1/src/io/input.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.loadFCSSet" href="#GigaSOM.loadFCSSet"><code>GigaSOM.loadFCSSet</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">loadFCSSet(name::Symbol, fns::Vector{String}, pids=workers(); applyCompensation=true, postLoad=(d,i)-&gt;d)::LoadedDataInfo</code></pre><p>This runs the FCS loading machinery in a distributed way, so that the files <code>fns</code> (with full path) are sliced into equal parts and saved as a distributed variable <code>name</code> on workers specified by <code>pids</code>.</p><p><code>applyCompensation</code> is passed to loadFCS function.</p><p>See <code>slicesof</code> for description of the slicing.</p><p><code>postLoad</code> is applied to the loaded FCS file data (and the index) – use this function to e.g. filter out certain columns right on loading, using <code>selectFCSColumns</code>.</p><p>The loaded dataset can be manipulated by the distributed functions, e.g.</p><ul><li><code>dselect</code> for removing columns</li><li><code>dscale</code> for normalization</li><li><code>dtransform_asinh</code> (and others) for transformation</li><li>etc.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/741568d3a3448e2d52b55deb401e3f15517994d1/src/io/input.jl#L98-L117">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.loadFCSSizes-Tuple{Array{String,1}}" href="#GigaSOM.loadFCSSizes-Tuple{Array{String,1}}"><code>GigaSOM.loadFCSSizes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">loadFCSSizes(fns::Vector{String})</code></pre><p>Load cell counts in many FCS files at once. Useful as input for <code>slicesof</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/741568d3a3448e2d52b55deb401e3f15517994d1/src/io/input.jl#L48-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.selectFCSColumns-Tuple{Array{String,1}}" href="#GigaSOM.selectFCSColumns-Tuple{Array{String,1}}"><code>GigaSOM.selectFCSColumns</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">selectFCSColumns(selectColnames::Vector{String})</code></pre><p>Return a function useful with <code>loadFCSSet</code>, which loads only the specified (prettified) column names from the FCS files. Use <code>getMetaData</code>, <code>getMarkerNames</code> and <code>cleanNames!</code> to retrieve the usable column names for a FCS.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/741568d3a3448e2d52b55deb401e3f15517994d1/src/io/input.jl#L148-L155">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.cleanNames!-Tuple{Array{String,1}}" href="#GigaSOM.cleanNames!-Tuple{Array{String,1}}"><code>GigaSOM.cleanNames!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">cleanNames!(mydata::Vector{String})</code></pre><p>Replaces problematic characters in column names, avoids duplicate names, and prefixes an &#39;_&#39; if the name starts with a number.</p><p><strong>Arguments:</strong></p><ul><li><code>mydata</code>: vector of names (gets modified)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/741568d3a3448e2d52b55deb401e3f15517994d1/src/io/process.jl#L1-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.compensate!-Tuple{Array{Float64,2},Array{Float64,2},Array{Int64,1}}" href="#GigaSOM.compensate!-Tuple{Array{Float64,2},Array{Float64,2},Array{Int64,1}}"><code>GigaSOM.compensate!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">compensate!(data::Matrix{Float64}, spillover::Matrix{Float64}, cols::Vector{Int})</code></pre><p>Apply a compensation matrix in <code>spillover</code> (the individual columns of which describe, in order, the spillover of <code>cols</code> in <code>data</code>) to the matrix <code>data</code> in-place.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/741568d3a3448e2d52b55deb401e3f15517994d1/src/io/process.jl#L101-L107">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.getMarkerNames-Tuple{DataFrames.DataFrame}" href="#GigaSOM.getMarkerNames-Tuple{DataFrames.DataFrame}"><code>GigaSOM.getMarkerNames</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">getMarkerNames(meta::DataFrame)::Tuple{Vector{String}, Vector{String}}</code></pre><p>Extract suitable raw names (useful for selecting columns) and pretty readable names (useful for humans) from FCS file metadata.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/741568d3a3448e2d52b55deb401e3f15517994d1/src/io/process.jl#L80-L86">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.getMetaData-Tuple{Dict{String,String}}" href="#GigaSOM.getMetaData-Tuple{Dict{String,String}}"><code>GigaSOM.getMetaData</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">getMetaData(f)</code></pre><p>Collect the meta data information in a more user friendly format.</p><p><strong>Arguments:</strong></p><ul><li><code>f</code>: input structure with <code>.params</code> and <code>.data</code> fields</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/741568d3a3448e2d52b55deb401e3f15517994d1/src/io/process.jl#L32-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.getSpillover-Tuple{Dict{String,String}}" href="#GigaSOM.getSpillover-Tuple{Dict{String,String}}"><code>GigaSOM.getSpillover</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">getSpillover(params::Dict{String, String})::Union{Tuple{Vector{String},Matrix{Float64}}, Nothing}</code></pre><p>Get a spillover matrix from FCS <code>params</code>. Returns a pair with description of columns to be applied, and with the actual spillover matrix. Returns <code>nothing</code> in case spillover is not present.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/741568d3a3448e2d52b55deb401e3f15517994d1/src/io/process.jl#L131-L137">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.parseSpillover-Tuple{String}" href="#GigaSOM.parseSpillover-Tuple{String}"><code>GigaSOM.parseSpillover</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">parseSpillover(str::String)::Union{Tuple{Vector{String},Matrix{Float64}}, Nothing}</code></pre><p>Parses the spillover matrix from the string from FCS parameter value.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/741568d3a3448e2d52b55deb401e3f15517994d1/src/io/process.jl#L112-L116">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.collectSlice-Tuple{Any,NTuple{4,Int64}}" href="#GigaSOM.collectSlice-Tuple{Any,NTuple{4,Int64}}"><code>GigaSOM.collectSlice</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">collectSlice(loadVec, (startFile, startOff, finalFile, finalOff)::Tuple{Int,Int,Int,Int})::Vector</code></pre><p>Alternative of <code>vcollectSlice</code> for 1D vectors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/741568d3a3448e2d52b55deb401e3f15517994d1/src/io/splitting.jl#L92-L96">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.slicesof-Tuple{Array{Int64,1},Int64}" href="#GigaSOM.slicesof-Tuple{Array{Int64,1},Int64}"><code>GigaSOM.slicesof</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">slicesof(lengths::Vector{Int}, slices::Int)::Vector{Tuple{Int,Int,Int,Int}}</code></pre><p>Given a list of <code>lengths</code> of input arrays, compute a slicing into a specified amount of equally-sized <code>slices</code>.</p><p>The output is a vector of 4-tuples where each specifies how to create one slice. The i-th tuple field contains, in order:</p><ul><li>the index of input array at which the i-th slice begins</li><li>first element of the i-th slice in that input array</li><li>the index of input array with the last element of the i-th slice</li><li>the index of the last element of the i-th slice in that array</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/741568d3a3448e2d52b55deb401e3f15517994d1/src/io/splitting.jl#L1-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.vcollectSlice-Tuple{Any,NTuple{4,Int64}}" href="#GigaSOM.vcollectSlice-Tuple{Any,NTuple{4,Int64}}"><code>GigaSOM.vcollectSlice</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">vcollectSlice(loadMtx, (startFile, startOff, finalFile, finalOff)::Tuple{Int,Int,Int,Int})::Matrix</code></pre><p>Given a method to obtain matrix content (<code>loadMtx</code>), reconstruct a slice from the information generated by <code>slicesof</code>.</p><p>This function is specialized for reconstructing matrices and arrays, where the &quot;element counts&quot; split by <code>slicesof</code> are in fact matrix rows. The function is therefore named <em>v</em>collect (the slicing and concatenation is <em>v</em>ertical).</p><p>The actual data content and loading method is abstracted out – function <code>loadMtx</code> gets the index of the input part that it is required to fetch (e.g. index of one FCS file), and is expected to return that input part as a whole matrix. <code>vcollectSlice</code> correctly calls this function as required and extracts relevant portions of the matrices, so that at the end the whole slice can be pasted together.</p><p>Example:</p><pre><code class="language-none"># get a list of files
filenames=[&quot;a.fcs&quot;, &quot;b.fcs&quot;]
# get descriptions of 5 equally sized parts of the data
slices = slicesof(loadFCSSizes(filenames), 5)

# reconstruct first 3 columns of the first slice
mySlice = vcollectSlice(
    i -&gt; last(loadFCS(slices[i]))[:,1:3],
    slices[1])
# (note: function loadFCS returns 4 items, the matrix is the last one)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/741568d3a3448e2d52b55deb401e3f15517994d1/src/io/splitting.jl#L48-L77">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.catmapbuckets-Tuple{Any,Array,Int64,Array{Int64,1}}" href="#GigaSOM.catmapbuckets-Tuple{Any,Array,Int64,Array{Int64,1}}"><code>GigaSOM.catmapbuckets</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">catmapbuckets(fn, a::Array, nbuckets::Int, buckets::Vector{Int}; bucketdim::Int=1)</code></pre><p>Same as <code>mapbuckets</code>, except concatenates the bucketing results in the bucketing dimension, thus creating a slightly neater matrix. <code>slicedims</code> is therefore fixed to <code>bucketdim</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/741568d3a3448e2d52b55deb401e3f15517994d1/src/base/dataops.jl#L245-L251">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.collect_extrema-Tuple{Any,Any}" href="#GigaSOM.collect_extrema-Tuple{Any,Any}"><code>GigaSOM.collect_extrema</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">collect_extrema(ex1, ex2)</code></pre><p>Helper for collecting the minimums and maximums of the data. <code>ex1</code>, <code>ex2</code> are arrays of pairs (min,max), this function combines the arrays element-wise and finds combined minima and maxima.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/741568d3a3448e2d52b55deb401e3f15517994d1/src/base/dataops.jl#L273-L279">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.combine_stats-Tuple{Any,Any}" href="#GigaSOM.combine_stats-Tuple{Any,Any}"><code>GigaSOM.combine_stats</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">combine_stats((s1, sqs1, n1), (s2, sqs2, n2))</code></pre><p>Helper for <code>dstat</code>-style functions that just adds up elements in triplets of vectors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/741568d3a3448e2d52b55deb401e3f15517994d1/src/base/dataops.jl#L78-L83">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.dapply_cols-Tuple{LoadedDataInfo,Any,Array{Int64,1}}" href="#GigaSOM.dapply_cols-Tuple{LoadedDataInfo,Any,Array{Int64,1}}"><code>GigaSOM.dapply_cols</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">dapply_cols(dInfo::LoadedDataInfo, fn, columns::Vector{Int})</code></pre><p>Apply a function <code>fn</code> over columns of a distributed dataset.</p><p><code>fn</code> gets <em>2</em> parameters:</p><ul><li>a data vector for (the whole column saved at one worker)</li><li>index of the column in the <code>columns</code> array (i.e. a number from <code>1:length(columns)</code>)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/741568d3a3448e2d52b55deb401e3f15517994d1/src/base/dataops.jl#L45-L54">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.dapply_rows-Tuple{LoadedDataInfo,Any}" href="#GigaSOM.dapply_rows-Tuple{LoadedDataInfo,Any}"><code>GigaSOM.dapply_rows</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">dapply_rows(dInfo::LoadedDataInfo, fn)</code></pre><p>Apply a function <code>fn</code> over rows of a distributed dataset.</p><p><code>fn</code> gets a single vector parameter for each row to transform.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/741568d3a3448e2d52b55deb401e3f15517994d1/src/base/dataops.jl#L63-L69">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.dcopy-Tuple{LoadedDataInfo,Symbol}" href="#GigaSOM.dcopy-Tuple{LoadedDataInfo,Symbol}"><code>GigaSOM.dcopy</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">dcopy(dInfo::LoadedDataInfo, newName::Symbol)</code></pre><p>Clone the dataset and store it under a new distributed name <code>newName</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/741568d3a3448e2d52b55deb401e3f15517994d1/src/base/dataops.jl#L2-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.dcount-Tuple{Int64,LoadedDataInfo}" href="#GigaSOM.dcount-Tuple{Int64,LoadedDataInfo}"><code>GigaSOM.dcount</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">dcount(ncats::Int, dInfo::LoadedDataInfo)::Vector{Int}</code></pre><p>Count the numbers of integer vector values stored in <code>dInfo</code>; assuming the values are in range 1–<code>ncats</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/741568d3a3448e2d52b55deb401e3f15517994d1/src/base/dataops.jl#L144-L149">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.dcount_buckets-Tuple{Int64,LoadedDataInfo,Int64,LoadedDataInfo}" href="#GigaSOM.dcount_buckets-Tuple{Int64,LoadedDataInfo,Int64,LoadedDataInfo}"><code>GigaSOM.dcount_buckets</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">dcount_buckets(ncats::Int, dInfo::LoadedDataInfo, nbuckets::Int, buckets::LoadedDataInfo)::Matrix{Int}</code></pre><p>Same as <code>dcount</code>, but counts the items in <code>dInfo</code> bucketed by <code>buckets</code> to produce a matrix of counts, with <code>ncats</code> rows and <code>nbuckets</code> columns.</p><p>Useful with <code>distributeFCSFileVector</code> to determine cluster distribution within files.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/741568d3a3448e2d52b55deb401e3f15517994d1/src/base/dataops.jl#L162-L170">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.dmedian-Tuple{LoadedDataInfo,Array{Int64,1}}" href="#GigaSOM.dmedian-Tuple{LoadedDataInfo,Array{Int64,1}}"><code>GigaSOM.dmedian</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">dmedian(dInfo::LoadedDataInfo, columns::Vector{Int})</code></pre><p>Compute a median in a distributed fashion, avoiding data transfer and memory capacity that is required to compute the median in the classical way by sorting. All data must be finite and defined. If the median is just between 2 values, the lower one is chosen.</p><p>The algorithm is approximative, searching for a good median by halving interval and counting how many values are below the threshold. <code>iters</code> can be increased to improve precision, each value adds roughly 1 bit to the precision. The default value is 20, which corresponds to precision 10e-6 times the data range.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/741568d3a3448e2d52b55deb401e3f15517994d1/src/base/dataops.jl#L303-L315">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.dmedian_buckets-Tuple{LoadedDataInfo,Int64,LoadedDataInfo,Array{Int64,1}}" href="#GigaSOM.dmedian_buckets-Tuple{LoadedDataInfo,Int64,LoadedDataInfo,Array{Int64,1}}"><code>GigaSOM.dmedian_buckets</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">dmedian_buckets(dInfo::LoadedDataInfo, nbuckets::Int, buckets::LoadedDataInfo, columns::Vector{Int}; iters=20)</code></pre><p>A version of <code>dmedian</code> that works with the bucketing information (i.e. clusters) from <code>nbuckets</code> and <code>buckets</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/741568d3a3448e2d52b55deb401e3f15517994d1/src/base/dataops.jl#L347-L352">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.dscale-Tuple{LoadedDataInfo,Array{Int64,1}}" href="#GigaSOM.dscale-Tuple{LoadedDataInfo,Array{Int64,1}}"><code>GigaSOM.dscale</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">dscale(dInfo::LoadedDataInfo, columns::Vector{Int})</code></pre><p>Scale the columns in the dataset to have mean 0 and sdev 1.</p><p>Prevents creation of NaNs by avoiding division by zero sdevs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/741568d3a3448e2d52b55deb401e3f15517994d1/src/base/dataops.jl#L188-L194">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.dselect" href="#GigaSOM.dselect"><code>GigaSOM.dselect</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">dselect(dInfo::LoadedDataInfo, columns::Vector{Int}; tgt=dInfo.val)</code></pre><p>Reduce dataset to selected columns, optionally save it under a different name.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/741568d3a3448e2d52b55deb401e3f15517994d1/src/base/dataops.jl#L11-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.dselect" href="#GigaSOM.dselect"><code>GigaSOM.dselect</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">function dselect(dInfo::LoadedDataInfo,
    currentColnames::Vector{String}, selectColnames::Vector{String};
    tgt=dInfo.val)::LoadedDataInfo</code></pre><p>Convenience overload of <code>dselect</code> that works with column names.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/741568d3a3448e2d52b55deb401e3f15517994d1/src/base/dataops.jl#L24-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.dstat-Tuple{LoadedDataInfo,Array{Int64,1}}" href="#GigaSOM.dstat-Tuple{LoadedDataInfo,Array{Int64,1}}"><code>GigaSOM.dstat</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">dstat(dInfo::LoadedDataInfo, columns::Vector{Int})</code></pre><p>Compute mean and standard deviation of the columns in dataset. Returns a tuple with a vector of means in <code>columns</code>, and a vector of corresponding sdevs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/741568d3a3448e2d52b55deb401e3f15517994d1/src/base/dataops.jl#L88-L93">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.dstat_buckets-Tuple{LoadedDataInfo,Int64,LoadedDataInfo,Array{Int64,1}}" href="#GigaSOM.dstat_buckets-Tuple{LoadedDataInfo,Int64,LoadedDataInfo,Array{Int64,1}}"><code>GigaSOM.dstat_buckets</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">dstat_buckets(dInfo::LoadedDataInfo, nbuckets::Int, buckets::LoadedDataInfo, columns::Vector{Int})</code></pre><p>A version of <code>dstat</code> that works with bucketing information (e.g. clusters).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/741568d3a3448e2d52b55deb401e3f15517994d1/src/base/dataops.jl#L115-L119">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.dtransform_asinh" href="#GigaSOM.dtransform_asinh"><code>GigaSOM.dtransform_asinh</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">dtransform_asinh(dInfo::LoadedDataInfo, columns::Vector{Int}, cofactor=5)</code></pre><p>Transform columns of the dataset by asinh transformation with <code>cofactor</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/741568d3a3448e2d52b55deb401e3f15517994d1/src/base/dataops.jl#L204-L208">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.mapbuckets-Tuple{Any,Array,Int64,Array{Int64,1}}" href="#GigaSOM.mapbuckets-Tuple{Any,Array,Int64,Array{Int64,1}}"><code>GigaSOM.mapbuckets</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">mapbuckets(fn, a::Array, nbuckets::Int, buckets::Vector{Int}; bucketdim::Int=1, slicedims=bucketdim)</code></pre><p>Apply the function <code>fn</code> over array <code>a</code> so that it processes the data by buckets defined by <code>buckets</code> (that contains integers in range <code>1:nbuckets</code>).</p><p>The buckets are sliced out in dimension specified by <code>bucketdim</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/741568d3a3448e2d52b55deb401e3f15517994d1/src/base/dataops.jl#L213-L220">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.update_extrema-NTuple{4,Any}" href="#GigaSOM.update_extrema-NTuple{4,Any}"><code>GigaSOM.update_extrema</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">update_extrema(counts, target, lim, mid)</code></pre><p>Helper for distributed median computation – returns updated extrema in <code>lims</code> depending on whether the item count in <code>counts</code> of values less than <code>mids</code> is less or higher than <code>targets</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/741568d3a3448e2d52b55deb401e3f15517994d1/src/base/dataops.jl#L284-L290">source</a></section></article><h2 id="SOM-training"><a class="docs-heading-anchor" href="#SOM-training">SOM training</a><a id="SOM-training-1"></a><a class="docs-heading-anchor-permalink" href="#SOM-training" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.distributedEpoch-Tuple{LoadedDataInfo,Array{Float64,2},Any}" href="#GigaSOM.distributedEpoch-Tuple{LoadedDataInfo,Array{Float64,2},Any}"><code>GigaSOM.distributedEpoch</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">distributedEpoch(dInfo::LoadedDataInfo, codes::Matrix{Float64}, tree)</code></pre><p>Execute the <code>doEpoch</code> in parallel on workers described by <code>dInfo</code> and collect the results. Returns pair of numerator and denominator matrices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/741568d3a3448e2d52b55deb401e3f15517994d1/src/analysis/core.jl#L206-L211">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.doEpoch-Tuple{Array{Float64,2},Array{Float64,2},Any}" href="#GigaSOM.doEpoch-Tuple{Array{Float64,2},Array{Float64,2},Any}"><code>GigaSOM.doEpoch</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">doEpoch(x::Array{Float64, 2}, codes::Array{Float64, 2}, tree)</code></pre><p>vectors and the adjustment in radius after each epoch.</p><p><strong>Arguments:</strong></p><ul><li><code>x</code>: training Data</li><li><code>codes</code>: Codebook</li><li><code>tree</code>: knn-compatible tree built upon the codes</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/741568d3a3448e2d52b55deb401e3f15517994d1/src/analysis/core.jl#L177-L186">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.initGigaSOM" href="#GigaSOM.initGigaSOM"><code>GigaSOM.initGigaSOM</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">initGigaSOM(trainInfo::LoadedDataInfo,
            xdim::Int64, ydim :: Int64 = xdim)</code></pre><p><code>initGigaSOM</code> overload for working with distributed-style <code>LoadedDataInfo</code> data. The rest of arguments is the same as in <code>initGigaSOM</code>.</p><p>Note that this function only uses the data saved on the first worker for initialization, and the init work is actually done on that worker to avoid unnecessary data copying.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/741568d3a3448e2d52b55deb401e3f15517994d1/src/analysis/core.jl#L39-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.initGigaSOM" href="#GigaSOM.initGigaSOM"><code>GigaSOM.initGigaSOM</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">initGigaSOM(train, xdim, ydim = xdim)</code></pre><p>Initializes a SOM by random selection from the training data.</p><p><strong>Arguments:</strong></p><ul><li><code>train</code>: codeBook vector as random input matrix from random workers</li><li><code>xdim, ydim</code>: geometry of the SOM</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/741568d3a3448e2d52b55deb401e3f15517994d1/src/analysis/core.jl#L1-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.mapToGigaSOM-Tuple{Som,Any}" href="#GigaSOM.mapToGigaSOM-Tuple{Som,Any}"><code>GigaSOM.mapToGigaSOM</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">mapToGigaSOM(som::Som, data;
             knnTreeFun = BruteTree,
             metric = Euclidean())</code></pre><p>Overload of <code>mapToGigaSOM</code> for simple DataFrames and matrices. This slices the data using <code>DistributedArrays</code>, sends them the workers, and runs normal <code>mapToGigaSOM</code>. Data is <code>undistribute</code>d after the computation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/741568d3a3448e2d52b55deb401e3f15517994d1/src/analysis/core.jl#L255-L262">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.mapToGigaSOM-Tuple{Som,LoadedDataInfo}" href="#GigaSOM.mapToGigaSOM-Tuple{Som,LoadedDataInfo}"><code>GigaSOM.mapToGigaSOM</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">mapToGigaSOM(som::Som, dInfo::LoadedDataInfo;
    knnTreeFun = BruteTree, metric = Euclidean(),
    output::Symbol=tmpSym(dInfo)::LoadedDataInfo</code></pre><p>Compute the index of the BMU for each row of the input data.</p><p><strong>Arguments</strong></p><ul><li><code>som</code>: a trained SOM</li><li><code>dInfo</code>: <code>LoadedDataInfo</code> that describes the loaded and distributed data</li><li><code>knnTreeFun</code>: Constructor of the KNN-tree (e.g. from NearestNeighbors package)</li><li><code>metric</code>: Passed as metric argument to the KNN-tree constructor</li><li><code>output</code>: Symbol to save the result, defaults to <code>tmpSym(dInfo)</code></li></ul><p>Data must have the same number of dimensions as the training dataset and will be normalised with the same parameters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/741568d3a3448e2d52b55deb401e3f15517994d1/src/analysis/core.jl#L221-L237">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.scaleEpochTime-Tuple{Int64,Int64}" href="#GigaSOM.scaleEpochTime-Tuple{Int64,Int64}"><code>GigaSOM.scaleEpochTime</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">scaleEpochTime(iteration::Int64, epochs::Int64)</code></pre><p>Convert iteration ID and epoch number to relative time in training.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/741568d3a3448e2d52b55deb401e3f15517994d1/src/analysis/core.jl#L280-L284">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.trainGigaSOM-Tuple{Som,Any}" href="#GigaSOM.trainGigaSOM-Tuple{Som,Any}"><code>GigaSOM.trainGigaSOM</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">trainGigaSOM(som::Som, train;
             kernelFun::Function = gaussianKernel,
             metric = Euclidean(),
             somDistFun = distMatrix(Chebyshev()),
             knnTreeFun = BruteTree,
             rStart = 0.0, rFinal=0.1, radiusFun=expRadius(-5.0),
             epochs = 20)</code></pre><p>Overload of <code>trainGigaSOM</code> for simple DataFrames and matrices. This slices the data using <code>DistributedArrays</code>, sends them the workers, and runs normal <code>trainGigaSOM</code>. Data is <code>undistribute</code>d after the computation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/741568d3a3448e2d52b55deb401e3f15517994d1/src/analysis/core.jl#L130-L142">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.trainGigaSOM-Tuple{Som,LoadedDataInfo}" href="#GigaSOM.trainGigaSOM-Tuple{Som,LoadedDataInfo}"><code>GigaSOM.trainGigaSOM</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">trainGigaSOM(som::Som, dInfo::LoadedDataInfo;
             kernelFun::Function = gaussianKernel,
             metric = Euclidean(),
             somDistFun = distMatrix(Chebyshev()),
             knnTreeFun = BruteTree,
             rStart = 0.0, rFinal=0.1, radiusFun=expRadius(-5.0),
             epochs = 20)</code></pre><p><strong>Arguments:</strong></p><ul><li><code>som</code>: object of type Som with an initialised som</li><li><code>dInfo</code>: <code>LoadedDataInfo</code> object that describes a loaded dataset</li><li><code>kernelFun::function</code>: optional distance kernel; one of (<code>bubbleKernel, gaussianKernel</code>)           default is <code>gaussianKernel</code></li><li><code>metric</code>: Passed as metric argument to the KNN-tree constructor</li><li><code>somDistFun</code>: Function for computing the distances in the SOM map</li><li><code>knnTreeFun</code>: Constructor of the KNN-tree (e.g. from NearestNeighbors package)</li><li><code>rStart</code>: optional training radius. If zero (default), it is computed from the SOM grid size.</li><li><code>rFinal</code>: target radius at the last epoch, defaults to 0.1</li><li><code>radiusFun</code>: Function that generates radius decay, e.g. <code>linearRadius</code> or <code>expRadius(10.0)</code></li><li><code>epochs</code>: number of SOM training iterations (default 10)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/741568d3a3448e2d52b55deb401e3f15517994d1/src/analysis/core.jl#L59-L80">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.bubbleKernel-Tuple{Any,Float64}" href="#GigaSOM.bubbleKernel-Tuple{Any,Float64}"><code>GigaSOM.bubbleKernel</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">bubbleKernel(x, r::Float64)</code></pre><p>Return a &quot;bubble&quot; (spherical) distribution kernel.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/741568d3a3448e2d52b55deb401e3f15517994d1/src/base/trainutils.jl#L112-L117">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.distMatrix" href="#GigaSOM.distMatrix"><code>GigaSOM.distMatrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">distMatrix(metric=Chebyshev())</code></pre><p>Return a function that uses the <code>metric</code> (compatible with metrics from package <code>Distances</code>) calculates distance matrixes from normal row-wise data matrices, using the <code>metric</code>.</p><p>Use as a parameter of <code>trainGigaSOM</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/741568d3a3448e2d52b55deb401e3f15517994d1/src/base/trainutils.jl#L134-L140">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.expRadius" href="#GigaSOM.expRadius"><code>GigaSOM.expRadius</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">expRadius(steepness::Float64)</code></pre><p>Return a function to be used as a <code>radiusFun</code> of <code>trainGigaSOM</code>, which causes exponencial decay with the selected steepness.</p><p>Use: <code>trainGigaSOM(..., radiusFun = expRadius(0.5))</code></p><p><strong>Arguments</strong></p><ul><li><code>steepness</code>: Steepness of exponential descent. Good values range from -100.0 (almost linear) to 100.0 (really quick decay).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/741568d3a3448e2d52b55deb401e3f15517994d1/src/base/trainutils.jl#L25-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.gaussianKernel-Tuple{Any,Float64}" href="#GigaSOM.gaussianKernel-Tuple{Any,Float64}"><code>GigaSOM.gaussianKernel</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">gaussianKernel(x, r::Float64)</code></pre><p>Return the value of normal distribution PDF (σ=<code>r</code>, μ=0) at <code>x</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/741568d3a3448e2d52b55deb401e3f15517994d1/src/base/trainutils.jl#L93-L97">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.gridRectangular-Tuple{Any,Any}" href="#GigaSOM.gridRectangular-Tuple{Any,Any}"><code>GigaSOM.gridRectangular</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">gridRectangular(xdim, ydim)</code></pre><p>Create coordinates of all neurons on a rectangular SOM.</p><p>The return-value is an array of size (Number-of-neurons, 2) with x- and y- coordinates of the neurons in the first and second column respectively. The distance between neighbours is 1.0. The point of origin is bottom-left. The first neuron sits at (0,0).</p><p><strong>Arguments</strong></p><ul><li><code>xdim</code>: number of neurons in x-direction</li><li><code>ydim</code>: number of neurons in y-direction</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/741568d3a3448e2d52b55deb401e3f15517994d1/src/base/trainutils.jl#L64-L79">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.linearRadius-Tuple{Float64,Float64,Int64,Int64}" href="#GigaSOM.linearRadius-Tuple{Float64,Float64,Int64,Int64}"><code>GigaSOM.linearRadius</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">linearRadius(initRadius::Float64, iteration::Int64, decay::String, epochs::Int64)</code></pre><p>Return a neighbourhood radius. Use as the <code>radiusFun</code> parameter for <code>trainGigaSOM</code>.</p><p><strong>Arguments</strong></p><ul><li><code>initRadius</code>: Initial Radius</li><li><code>finalRadius</code>: Final Radius</li><li><code>iteration</code>: Training iteration</li><li><code>epochs</code>: Total number of epochs</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/741568d3a3448e2d52b55deb401e3f15517994d1/src/base/trainutils.jl#L2-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.thresholdKernel" href="#GigaSOM.thresholdKernel"><code>GigaSOM.thresholdKernel</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">thresholdKernel(x, r::Float64)</code></pre><p>Simple FlowSOM-like hard-threshold kernel</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/741568d3a3448e2d52b55deb401e3f15517994d1/src/base/trainutils.jl#L122-L126">source</a></section></article><h2 id="Embedding"><a class="docs-heading-anchor" href="#Embedding">Embedding</a><a id="Embedding-1"></a><a class="docs-heading-anchor-permalink" href="#Embedding" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.embedGigaSOM-Tuple{Som,Any}" href="#GigaSOM.embedGigaSOM-Tuple{Som,Any}"><code>GigaSOM.embedGigaSOM</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">embedGigaSOM(som::GigaSOM.Som,
             data;
             knnTreeFun = BruteTree,
             metric = Euclidean(),
             k::Int64=0,
             adjust::Float64=1.0,
             smooth::Float64=0.0,
             m::Float64=10.0)</code></pre><p>Overload of <code>embedGigaSOM</code> for simple DataFrames and matrices. This slices the data using <code>DistributedArrays</code>, sends them the workers, and runs normal <code>embedGigaSOM</code>. All data is properly <code>undistribute</code>d after the computation.</p><p><strong>Examples:</strong></p><p>Produce a 2-column matrix with 2D cell coordinates:</p><pre><code class="language-none">e = embedGigaSOM(som, data)</code></pre><p>Plot the result using 2D histogram from Gadfly:</p><pre><code class="language-none">using Gadfly
draw(PNG(&quot;output.png&quot;,20cm,20cm),
     plot(x=e[:,1], y=e[:,2],
     Geom.histogram2d(xbincount=200, ybincount=200)))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/741568d3a3448e2d52b55deb401e3f15517994d1/src/analysis/embedding.jl#L68-L96">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.embedGigaSOM-Tuple{Som,LoadedDataInfo}" href="#GigaSOM.embedGigaSOM-Tuple{Som,LoadedDataInfo}"><code>GigaSOM.embedGigaSOM</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">embedGigaSOM(som::GigaSOM.Som,
             dInfo::LoadedDataInfo;
             knnTreeFun = BruteTree,
             metric = Euclidean(),
             k::Int64=0,
             adjust::Float64=1.0,
             smooth::Float64=0.0,
             m::Float64=10.0,
             output::Symbol=tmpSym(dInfo))::LoadedDataInfo</code></pre><p>Return a data frame with X,Y coordinates of EmbedSOM projection of the data.</p><p><strong>Arguments:</strong></p><ul><li><code>som</code>: a trained SOM</li><li><code>dInfo</code>: <code>LoadedDataInfo</code> that describes the loaded dataset</li><li><code>knnTreeFun</code>: Constructor of the KNN-tree (e.g. from NearestNeighbors package)</li><li><code>metric</code>: Passed as metric argument to the KNN-tree constructor</li><li><code>k</code>: number of nearest neighbors to consider (high values get quadratically slower)</li><li><code>adjust</code>: position adjustment parameter (higher values avoid non-local approximations)</li><li><code>smooth</code>: approximation smoothness (the higher the value, the larger the neighborhood of approximate local linearity of the projection)</li><li><code>m</code>: exponential decay rate for the score when approaching the <code>k+1</code>-th neighbor distance</li><li><code>output</code>: variable name for storing the distributed result</li></ul><p>Data must have the same number of dimensions as the training dataset, and must be normalized using the same parameters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/741568d3a3448e2d52b55deb401e3f15517994d1/src/analysis/embedding.jl#L1-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.embedGigaSOM_internal-Tuple{Som,Array{Float64,2},Any,Int64,Float64,Float64,Float64}" href="#GigaSOM.embedGigaSOM_internal-Tuple{Som,Array{Float64,2},Any,Int64,Float64,Float64,Float64}"><code>GigaSOM.embedGigaSOM_internal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">embedGigaSOM_internal(som::GigaSOM.Som,
                      data::Matrix{Float64},
                      tree,
                      k::Int64,
                      adjust::Float64,
                      boost::Float64,
                      m::Float64)</code></pre><p>Internal function to compute parts of the embedding on a prepared kNN-tree structure (<code>tree</code>) and <code>smooth</code> converted to <code>boost</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/741568d3a3448e2d52b55deb401e3f15517994d1/src/analysis/embedding.jl#L127-L138">source</a></section></article><h2 id="Distributed-processing-tools"><a class="docs-heading-anchor" href="#Distributed-processing-tools">Distributed processing tools</a><a id="Distributed-processing-tools-1"></a><a class="docs-heading-anchor-permalink" href="#Distributed-processing-tools" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.distribute_array-Tuple{Symbol,Array,Any}" href="#GigaSOM.distribute_array-Tuple{Symbol,Array,Any}"><code>GigaSOM.distribute_array</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">distribute_array(sym, x::Array, pids; dim=1)::LoadedDataInfo</code></pre><p>Distribute roughly equal parts of array <code>x</code> separated on dimension <code>dim</code> among <code>pids</code> into a worker-local variable <code>sym</code>.</p><p>Returns the <code>LoadedDataInfo</code> structure for the distributed data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/741568d3a3448e2d52b55deb401e3f15517994d1/src/base/distributed.jl#L69-L76">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.distribute_darray-Tuple{Symbol,DistributedArrays.DArray}" href="#GigaSOM.distribute_darray-Tuple{Symbol,DistributedArrays.DArray}"><code>GigaSOM.distribute_darray</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">distribute_darray(sym, dd::DArray)::LoadedDataInfo</code></pre><p>Distribute the distributed array parts from <code>dd</code> into worker-local variable <code>sym</code>.</p><p>Returns the <code>LoadedDataInfo</code> structure for the distributed data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/741568d3a3448e2d52b55deb401e3f15517994d1/src/base/distributed.jl#L94-L101">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.distributed_collect" href="#GigaSOM.distributed_collect"><code>GigaSOM.distributed_collect</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">distributed_collect(dInfo::LoadedDataInfo, dim=1; free=false)</code></pre><p>Distributed collect (just as the other overload) that works with <code>LoadedDataInfo</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/741568d3a3448e2d52b55deb401e3f15517994d1/src/base/distributed.jl#L313-L318">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.distributed_collect" href="#GigaSOM.distributed_collect"><code>GigaSOM.distributed_collect</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">distributed_collect(val::Symbol, workers, dim=1; free=false)</code></pre><p>Collect the arrays distributed on <code>workers</code> under value <code>val</code> into an array. The individual arrays are pasted in the dimension specified by <code>dim</code>, i.e. <code>dim=1</code> is roughly equivalent to using <code>vcat</code>, and <code>dim=2</code> to <code>hcat</code>.</p><p><code>val</code> must be an Array-based type; the function will otherwise fail.</p><p>If <code>free</code> is true, the <code>val</code> is undistributed after collection.</p><p>This preallocates the array for results, and is thus more efficient than e.g. using <code>distributed_mapreduce</code> with <code>vcat</code> for folding.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/741568d3a3448e2d52b55deb401e3f15517994d1/src/base/distributed.jl#L279-L292">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.distributed_exec-Tuple{Any,Any,Any}" href="#GigaSOM.distributed_exec-Tuple{Any,Any,Any}"><code>GigaSOM.distributed_exec</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">distributed_exec(val, fn, workers)</code></pre><p>Execute a function on workers, taking <code>val</code> as a parameter. Results are not collected. This is optimal for various side-effect-causing computations that are not expressible with <code>distributed_transform</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/741568d3a3448e2d52b55deb401e3f15517994d1/src/base/distributed.jl#L129-L135">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.distributed_exec-Tuple{LoadedDataInfo,Any}" href="#GigaSOM.distributed_exec-Tuple{LoadedDataInfo,Any}"><code>GigaSOM.distributed_exec</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">distributed_exec(dInfo::LoadedDataInfo, fn)</code></pre><p>Variant of <code>distributed_exec</code> that works with <code>LoadedDataInfo</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/741568d3a3448e2d52b55deb401e3f15517994d1/src/base/distributed.jl#L147-L151">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.distributed_foreach-Tuple{Array{T,1} where T,Any,Any}" href="#GigaSOM.distributed_foreach-Tuple{Array{T,1} where T,Any,Any}"><code>GigaSOM.distributed_foreach</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">distributed_foreach(arr::Vector, fn, workers)</code></pre><p>Call a function <code>fn</code> on <code>workers</code>, with a single parameter arriving from the corresponding position in <code>arr</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/741568d3a3448e2d52b55deb401e3f15517994d1/src/base/distributed.jl#L323-L328">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.distributed_mapreduce-NTuple{4,Any}" href="#GigaSOM.distributed_mapreduce-NTuple{4,Any}"><code>GigaSOM.distributed_mapreduce</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">distributed_mapreduce(val, map, fold, workers)</code></pre><p>Run <code>map</code>s (non-modifying transforms on the data) and <code>fold</code>s (2-to-1 reductions) on the worker-local data (in <code>val</code>s) distributed on <code>workers</code> and return the final reduced result.</p><p>It is assumed that the fold operation is associative, but not commutative (as in semigroups). If there are no workers, operation returns <code>nothing</code> (we don&#39;t have a monoid to magically conjure zero elements :[ ).</p><p>In current version, the reduce step is a sequential left fold, executed in the main process.</p><p><strong>Example</strong></p><pre><code class="language-none"># compute the mean of all distributed data
sum,len = distributed_mapreduce(:myData,
    (d) -&gt; (sum(d),length(d)),
    ((s1, l1), (s2, l2)) -&gt; (s1+s2, l1+l2),
    workers())
println(sum/len)</code></pre><p><strong>Processing multiple arguments (a.k.a. &quot;zipWith&quot;)</strong></p><p>The <code>val</code> here does not necessarily need to refer to a symbol, you can easily pass in a quoted tuple, which will be unquoted in the function parameter. For example, distributed values <code>:a</code> and <code>:b</code> can be joined as such:</p><pre><code class="language-none">distributed_mapreduce(:((a,b)),
    ((a,b)::Tuple) -&gt; [a b],
    vcat,
    workers())</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/741568d3a3448e2d52b55deb401e3f15517994d1/src/base/distributed.jl#L187-L219">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.distributed_mapreduce-Tuple{Array{LoadedDataInfo,1},Any,Any}" href="#GigaSOM.distributed_mapreduce-Tuple{Array{LoadedDataInfo,1},Any,Any}"><code>GigaSOM.distributed_mapreduce</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">distributed_mapreduce(dInfo1::LoadedDataInfo, dInfo2::LoadedDataInfo, map, fold)</code></pre><p>Variant of <code>distributed_mapreduce</code> that works with more <code>LoadedDataInfo</code>s at once.  The data must be distributed on the same set of workers, in the same order.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/741568d3a3448e2d52b55deb401e3f15517994d1/src/base/distributed.jl#L259-L265">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.distributed_mapreduce-Tuple{Array{T,1} where T,Any,Any,Any}" href="#GigaSOM.distributed_mapreduce-Tuple{Array{T,1} where T,Any,Any,Any}"><code>GigaSOM.distributed_mapreduce</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">distributed_mapreduce(vals::Vector, map, fold, workers)</code></pre><p>Variant of <code>distributed_mapreduce</code> that works with more distributed variables at once.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/741568d3a3448e2d52b55deb401e3f15517994d1/src/base/distributed.jl#L249-L254">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.distributed_mapreduce-Tuple{LoadedDataInfo,Any,Any}" href="#GigaSOM.distributed_mapreduce-Tuple{LoadedDataInfo,Any,Any}"><code>GigaSOM.distributed_mapreduce</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">distributed_mapreduce(dInfo::LoadedDataInfo, map, fold)</code></pre><p>Distributed map/reduce (just as the other overload of <code>distributed_mapreduce</code>) that works with <code>LoadedDataInfo</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/741568d3a3448e2d52b55deb401e3f15517994d1/src/base/distributed.jl#L239-L244">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.distributed_transform" href="#GigaSOM.distributed_transform"><code>GigaSOM.distributed_transform</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">distributed_transform(dInfo::LoadedDataInfo, fn, tgt::Symbol=dInfo.val)::LoadedDataInfo</code></pre><p>Same as <code>distributed_transform</code>, but specialized for <code>LoadedDataInfo</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/741568d3a3448e2d52b55deb401e3f15517994d1/src/base/distributed.jl#L174-L178">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.distributed_transform" href="#GigaSOM.distributed_transform"><code>GigaSOM.distributed_transform</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">distributed_transform(val, fn, workers, tgt::Symbol=val)</code></pre><p>Transform the worker-local distributed data available as <code>val</code> on <code>workers</code> in-place, by a function <code>fn</code>. Store the result as <code>tgt</code> (default <code>val</code>)</p><p><strong>Example</strong></p><pre><code class="language-none"># multiply all saved data by 2
distributed_transform(:myData, (d)-&gt;(2*d), workers())</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/741568d3a3448e2d52b55deb401e3f15517994d1/src/base/distributed.jl#L156-L166">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.get_from-Tuple{Any,Any}" href="#GigaSOM.get_from-Tuple{Any,Any}"><code>GigaSOM.get_from</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_from(worker,val)</code></pre><p>Get a value <code>val</code> from a remote <code>worker</code>; quoting of <code>val</code> works just as with <code>save_at</code>. Returns a future with the requested value.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/741568d3a3448e2d52b55deb401e3f15517994d1/src/base/distributed.jl#L41-L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.get_val_from-Tuple{Any,Any}" href="#GigaSOM.get_val_from-Tuple{Any,Any}"><code>GigaSOM.get_val_from</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_val_from(worker,val)</code></pre><p>Shortcut for instantly fetching the future from <code>get_from</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/741568d3a3448e2d52b55deb401e3f15517994d1/src/base/distributed.jl#L51-L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.remove_from-Tuple{Any,Symbol}" href="#GigaSOM.remove_from-Tuple{Any,Symbol}"><code>GigaSOM.remove_from</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">remove_from(worker,sym)</code></pre><p>Sets symbol <code>sym</code> on <code>worker</code> to <code>nothing</code>, effectively freeing the data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/741568d3a3448e2d52b55deb401e3f15517994d1/src/base/distributed.jl#L60-L64">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.save_at-Tuple{Any,Symbol,Any}" href="#GigaSOM.save_at-Tuple{Any,Symbol,Any}"><code>GigaSOM.save_at</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">save_at(worker, sym, val)</code></pre><p>Saves value <code>val</code> to symbol <code>sym</code> at <code>worker</code>. <code>sym</code> should be quoted (or contain a symbol). <code>val</code> gets unquoted in the processing and evaluated at the worker, quote it if you want to pass exact command to the worker.</p><p>This is loosely based on the package ParallelDataTransfers, but made slightly more flexible by omitting/delaying the explicit fetches etc. In particular, <code>save_at</code> is roughly the same as <code>ParallelDataTransfers.sendto</code>, and <code>get_val_from</code> works very much like <code>ParallelDataTransfers.getfrom</code>.</p><p><strong>Return value</strong></p><p>A future with Nothing that can be fetched to see that the operation has finished.</p><p>Examples:     addprocs(1)     save<em>at(2,:x,123)       # saves 123     save</em>at(2,:x,myid())    # saves 1     save<em>at(2,:x,:(myid())) # saves 2     save</em>at(2,:x,:(:x))     # saves the symbol :x                             # (just :x won&#39;t work because of unquoting)</p><p><strong>Note: Symbol scope</strong></p><p>The symbols are saved in Main module on the corresponding worker. For example, <code>save_at(1, :x, nothing)</code> <em>will</em> erase your local <code>x</code> variable. Beware of name collisions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/741568d3a3448e2d52b55deb401e3f15517994d1/src/base/distributed.jl#L1-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.tmpSym-Tuple{LoadedDataInfo}" href="#GigaSOM.tmpSym-Tuple{LoadedDataInfo}"><code>GigaSOM.tmpSym</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">tmpSym(dInfo::LoadedDataInfo; prefix=&quot;&quot;, suffix=&quot;_tmp&quot;)</code></pre><p>Decorate the symbol from <code>dInfo</code> with prefix and suffix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/741568d3a3448e2d52b55deb401e3f15517994d1/src/base/distributed.jl#L347-L351">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.tmpSym-Tuple{Symbol}" href="#GigaSOM.tmpSym-Tuple{Symbol}"><code>GigaSOM.tmpSym</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">tmpSym(s::Symbol; prefix=&quot;&quot;, suffix=&quot;_tmp&quot;)</code></pre><p>Decorate a symbol <code>s</code> with prefix and suffix, to create a good name for a related temporary value.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/741568d3a3448e2d52b55deb401e3f15517994d1/src/base/distributed.jl#L337-L342">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.undistribute-Tuple{LoadedDataInfo}" href="#GigaSOM.undistribute-Tuple{LoadedDataInfo}"><code>GigaSOM.undistribute</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">undistribute(dInfo::LoadedDataInfo)</code></pre><p>Remove the loaded data described by <code>dInfo</code> from the corresponding workers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/741568d3a3448e2d52b55deb401e3f15517994d1/src/base/distributed.jl#L120-L124">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.undistribute-Tuple{Symbol,Any}" href="#GigaSOM.undistribute-Tuple{Symbol,Any}"><code>GigaSOM.undistribute</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">undistribute(sym, workers)</code></pre><p>Remove the loaded data from workers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/741568d3a3448e2d52b55deb401e3f15517994d1/src/base/distributed.jl#L109-L113">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.defaultFiles-Tuple{Any,Any}" href="#GigaSOM.defaultFiles-Tuple{Any,Any}"><code>GigaSOM.defaultFiles</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">defaultFiles(s, pids)</code></pre><p>Make a good set of filenames for saving a dataset.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/741568d3a3448e2d52b55deb401e3f15517994d1/src/io/dio.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.distributed_export" href="#GigaSOM.distributed_export"><code>GigaSOM.distributed_export</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">distributed_export(dInfo::LoadedDataInfo, files=defaultFiles(dInfo.val, dInfo.workers))</code></pre><p>Overloaded functionality for <code>LoadedDataInfo</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/741568d3a3448e2d52b55deb401e3f15517994d1/src/io/dio.jl#L30-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.distributed_export" href="#GigaSOM.distributed_export"><code>GigaSOM.distributed_export</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">distributed_export(sym::Symbol, pids, files=defaultFiles(sym,pids))</code></pre><p>Export the content of symbol <code>sym</code> by each worker specified by <code>pids</code> to a corresponding filename in <code>files</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/741568d3a3448e2d52b55deb401e3f15517994d1/src/io/dio.jl#L10-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.distributed_import" href="#GigaSOM.distributed_import"><code>GigaSOM.distributed_import</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">distributed_import(dInfo::LoadedDataInfo, files=defaultFiles(dInfo.val, dInfo.workers))</code></pre><p>Overloaded functionality for <code>LoadedDataInfo</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/741568d3a3448e2d52b55deb401e3f15517994d1/src/io/dio.jl#L62-L66">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.distributed_import" href="#GigaSOM.distributed_import"><code>GigaSOM.distributed_import</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">distributed_import(sym::Symbol, pids, files=defaultFiles(sym,pids))</code></pre><p>Import the content of symbol <code>sym</code> by each worker specified by <code>pids</code> from the corresponding filename in <code>files</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/741568d3a3448e2d52b55deb401e3f15517994d1/src/io/dio.jl#L42-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.distributed_unlink" href="#GigaSOM.distributed_unlink"><code>GigaSOM.distributed_unlink</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">distributed_unlink(dInfo::LoadedDataInfo, files=defaultFiles(dInfo.val, dInfo.workers))</code></pre><p>Overloaded functionality for <code>LoadedDataInfo</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/741568d3a3448e2d52b55deb401e3f15517994d1/src/io/dio.jl#L84-L88">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GigaSOM.distributed_unlink" href="#GigaSOM.distributed_unlink"><code>GigaSOM.distributed_unlink</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">distributed_unlink(sym::Symbol, pids, files=defaultFiles(sym,pids))</code></pre><p>Remove the files created by <code>distributed_export</code> with the same parameters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/741568d3a3448e2d52b55deb401e3f15517994d1/src/io/dio.jl#L74-L78">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../tutorials/whereToGoNext/">« Conclusion</a><a class="docs-footer-nextpage" href="../howToContribute/">How to contribute »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 30 June 2020 12:23">Tuesday 30 June 2020</span>. Using Julia version 1.3.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
