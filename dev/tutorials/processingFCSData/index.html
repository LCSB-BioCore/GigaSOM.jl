<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Cytometry data · GigaSOM.jl</title><link rel="canonical" href="https://lcsb-biocore.github.io/GigaSOM.jl/stable/tutorials/processingFCSData/"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/gigasomlogotransp.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="GigaSOM.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">GigaSOM.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../background/">Background</a></li><li><span class="tocitem">Tutorial</span><ul><li><a class="tocitem" href="../basicUsage/">Introduction</a></li><li class="is-active"><a class="tocitem" href>Cytometry data</a><ul class="internal"><li><a class="tocitem" href="#Work-with-distributed-data"><span>Work with distributed data</span></a></li><li><a class="tocitem" href="#Working-with-larger-datasets"><span>Working with larger datasets</span></a></li></ul></li><li><a class="tocitem" href="../distributedProcessing/">Advanced distributed processing</a></li><li><a class="tocitem" href="../whereToGoNext/">Conclusion</a></li></ul></li><li><a class="tocitem" href="../../functions/">Functions</a></li><li><a class="tocitem" href="../../howToContribute/">How to contribute</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorial</a></li><li class="is-active"><a href>Cytometry data</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Cytometry data</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/master/docs/src/tutorials/processingFCSData.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Tutorial-2:-Working-with-cytometry-data"><a class="docs-heading-anchor" href="#Tutorial-2:-Working-with-cytometry-data">Tutorial 2: Working with cytometry data</a><a id="Tutorial-2:-Working-with-cytometry-data-1"></a><a class="docs-heading-anchor-permalink" href="#Tutorial-2:-Working-with-cytometry-data" title="Permalink"></a></h1><p>You can load any FCS file using <a href="../../functions/#GigaSOM.loadFCS-Tuple{String}"><code>loadFCS</code></a> function. For example, the Levine dataset (<a href="https://flowrepository.org/id/FR-FCM-ZZPH">obtainable here</a>) may be loaded as such:</p><pre><code class="language-none">params, data = loadFCS(&quot;Levine_13dim.fcs&quot;)</code></pre><p><code>params</code> will now contain the list of FCS parameters; you can parse a lot of interesting information from it using the <a href="../../functions/#GigaSOM.getMetaData-Tuple{Dict{String,String}}"><code>getMetaData</code></a> function:</p><pre><code class="language-julia">getMetaData(params)</code></pre><pre><code class="language-none">14×8 DataFrames.DataFrame. Omitted printing of 3 columns
│ Row │ E      │ S      │ N      │ RMIN              │ R      │
│     │ String │ String │ String │ String            │ String │
├─────┼────────┼────────┼────────┼───────────────────┼────────┤
│ 1   │ 0,0    │        │ CD45   │ -2.03601189282714 │ 1024   │
│ 2   │ 0,0    │        │ CD45RA │ -2.99700270621007 │ 1024   │
│ 3   │ 0,0    │        │ CD19   │ -3.05850183816765 │ 1024   │
│ 4   │ 0,0    │        │ CD11b  │ -2.99956408593931 │ 1024   │
│ 5   │ 0,0    │        │ CD4    │ -2.22860674361335 │ 1024   │
│ 6   │ 0,0    │        │ CD8    │ -3.29174106765763 │ 1024   │
│ 7   │ 0,0    │        │ CD34   │ -2.74278770893026 │ 1024   │
│ 8   │ 0,0    │        │ CD20   │ -3.40866348184011 │ 1024   │
│ 9   │ 0,0    │        │ CD33   │ -2.31371406643428 │ 1024   │
│ 10  │ 0,0    │        │ CD123  │ -3.02624638359366 │ 1024   │
│ 11  │ 0,0    │        │ CD38   │ -3.14752313833461 │ 1024   │
│ 12  │ 0,0    │        │ CD90   │ -2.55305031846157 │ 1024   │
│ 13  │ 0,0    │        │ CD3    │ -3.52459385416266 │ 1024   │
│ 14  │ 0,0    │        │ label  │ 1                 │ 1024   │</code></pre><p><code>data</code> is a matrix with cell expressions, one cell per row, one marker per column. If you want to run SOM analysis on it, you can cluster and visualize it just as in the previous tutorial, with one exception- we start with cutting off the <code>label</code> column that contains <code>NaN</code> values:</p><pre><code class="language-none">
data = data[:,1:13]
som = initGigaSOM(data, 16, 16)
som = trainGigaSOM(som, data)
clusters = mapToGigaSOM(som, data)
e = embedGigaSOM(som, data)

# ... save/plot results, etc...</code></pre><h2 id="Work-with-distributed-data"><a class="docs-heading-anchor" href="#Work-with-distributed-data">Work with distributed data</a><a id="Work-with-distributed-data-1"></a><a class="docs-heading-anchor-permalink" href="#Work-with-distributed-data" title="Permalink"></a></h2><p>Usual experiments produce multiple FCS files, and distributed or parallel processing is very helpful in crunching through all the data.</p><p>To load multiple FCS files, use <a href="../../functions/#GigaSOM.loadFCSSet"><code>loadFCSSet</code></a>. This function works well in the &quot;usual&quot; single-process environment, but additionally it is designed to handle situations when the data is too big to fit into memory, and attempts to split them into available distributed workers workers.</p><p>For the purpose of data distribution, you need to identify each dataset by an unique <strong>dataset name</strong> that will be used for identifying your loaded data in the cluster environment.  The dataset name is a simple Julia symbols; basically a variable name that is prefixed with a <code>:</code> colon.</p><p>For example, we can load the Levine13 dataset as such:</p><pre><code class="language-julia">datainfo = loadFCSSet(:levine, [&quot;Levine_13dim.fcs&quot;])</code></pre><p>Expectably, if you have more files, just write their names into the array and the function will handle the rest.</p><p>The result <code>datainfo</code> carries informaton about your selected dataset name and its distribution among the cluster. It can be used just as the &quot;data&quot; parameter in all SOM-related functions again; e.g. as <code>trainGigaSOM(som, datainfo)</code>.</p><p>The following example exploits the possibility to actually split the data, and processes the Levine dataset parallelly on 2 workers:</p><pre><code class="language-julia">using Distributed
addprocs(2)                 # add any number of CPUs/tasks/workers you have available
@everywhere using GigaSOM   # load GigaSOM also on the workers

datainfo = loadFCSSet(:levine, [&quot;Levine_13dim.fcs&quot;]) # add more files as needed

dselect(datainfo, Vector(1:13))   # select columns that contain expressions (column 14 contains labels)
som = initGigaSOM(datainfo, 20, 20)
som = trainGigaSOM(som, datainfo)</code></pre><p>To prevent memory overload of the &quot;master&quot; computation node, the results of all per-cell operations are also stored in distributed datainfo objects. In this case, the following code does the embedding, but leaves the resulting data safely scattered among the cluster:</p><pre><code class="language-julia">e = embedGigaSOM(som, datainfo)</code></pre><p>If you are sure you have enough RAM, you can collect the data to the master node. (In case of the relatively small Levine13 dataset, you very probably have the required 2.5MB of RAM, but there are many larger datasets.)</p><pre><code class="language-julia">e = distributed_collect(e)</code></pre><pre><code class="language-none">167044×2 Array{Float64,2}:
 16.8251   11.5002
 18.2608   12.884
 12.0103    5.18401
 18.381    12.3436
 18.357    11.6622
 14.8936   12.0897
 17.6441   12.3652
 17.8752   12.7206
 17.301    11.0767
 14.2055   12.2227
  ⋮</code></pre><h2 id="Working-with-larger-datasets"><a class="docs-heading-anchor" href="#Working-with-larger-datasets">Working with larger datasets</a><a id="Working-with-larger-datasets-1"></a><a class="docs-heading-anchor-permalink" href="#Working-with-larger-datasets" title="Permalink"></a></h2><p>In this example we will use a subset of the Cytometry data <a href="https://doi.org/10.1038/nbt.2317">by Bodenmiller et al.</a>. This data-set contains samples from peripheral blood mononuclear cells (PBMCs) in unstimulated and stimulated conditions for 8 healthy donors.</p><p>10 cell surface markers (lineage markers) are used to identify different cell populations. The dataset is described in two files:</p><ul><li><code>PBMC8_panel.xlsx</code> (with antigen names categorized as lineage markers and functional markers)</li><li><code>PBMC8_metadata.xlsx</code> (file names, sample IDs, condition IDs and patient IDs)</li></ul><h3 id="Download-and-prepare-the-dataset"><a class="docs-heading-anchor" href="#Download-and-prepare-the-dataset">Download and prepare the dataset</a><a id="Download-and-prepare-the-dataset-1"></a><a class="docs-heading-anchor-permalink" href="#Download-and-prepare-the-dataset" title="Permalink"></a></h3><p>The example data can be downloaded from <a href="http://imlspenticton.uzh.ch/robinson_lab/cytofWorkflow/">imlspenticton.uzh.ch/robinson_lab/cytofWorkflow/</a></p><p>You can fetch the files directly from within Julia:</p><pre><code class="language-julia"># fetch the required data for testing and download the zip archive and unzip it
dataFiles = [&quot;PBMC8_metadata.xlsx&quot;, &quot;PBMC8_panel.xlsx&quot;, &quot;PBMC8_fcs_files.zip&quot;]
for f in dataFiles
    if !isfile(f)
        download(&quot;http://imlspenticton.uzh.ch/robinson_lab/cytofWorkflow/&quot;*f, f)
        if occursin(&quot;.zip&quot;, f)
            run(`unzip PBMC8_fcs_files.zip`)
        end
    end
end</code></pre><p>The metadata is present in external files; we read it into a <code>DataFrame</code> and extract information about FCS data columns from there. First, we read the actual content using the XLSX package:</p><pre><code class="language-julia">using XLSX
md = GigaSOM.DataFrame(readtable(&quot;PBMC8_metadata.xlsx&quot;, &quot;Sheet1&quot;, infer_eltypes=true)...)
panel = GigaSOM.DataFrame(readtable(&quot;PBMC8_panel.xlsx&quot;, &quot;Sheet1&quot;, infer_eltypes=true)...)</code></pre><p>After that, we can get the parameter structure from the first FCS files:</p><pre><code class="language-julia">_, fcsParams = loadFCSHeader(md[1, :file_name])</code></pre><p>Continue with extracting marker names using the prepared functions:</p><pre><code class="language-julia">_, fcsAntigens = getMarkerNames(getMetaData(fcsParams))</code></pre><p>Now, see which antigens we want to use (assume we want only the lineage markers):</p><pre><code class="language-julia">antigens = panel[panel[:,:Lineage].==1, :Antigen]</code></pre><p>Finally, it is often useful to make the names a bit more Julia-friendly and predictable:</p><pre><code class="language-julia">cleanNames!(antigens)
cleanNames!(fcsAntigens)</code></pre><h3 id="Load-and-prepare-the-data"><a class="docs-heading-anchor" href="#Load-and-prepare-the-data">Load and prepare the data</a><a id="Load-and-prepare-the-data-1"></a><a class="docs-heading-anchor-permalink" href="#Load-and-prepare-the-data" title="Permalink"></a></h3><p>Now we have the vector of <code>fcsAntigens</code> that the FCS files store, and list of <code>antigens</code> that we want to analyze. We continue by loading the data, reducing it to the desired antigens and transforming it a bit:</p><pre><code class="language-julia">di = loadFCSSet(:pbmc8, md[:,:file_name])</code></pre><p>(If data distribution and parallelization is required, you must add parallel workers using <code>addprocs</code> <strong>before</strong> this step.)</p><p>Now that the data is loaded, let&#39;s prepare them a bit by reducing to actual interesting columns, transformation and scaling:</p><pre><code class="language-julia"># select only the columns that correspond to the lineage antigens we have prepared before
dselect(di, fcsAntigens, antigens)

cols = Vector(1:length(antigens)) # shortcut for &quot;all rows&quot;

# perform asinh transformation on all data in the dataset, &#39;5&#39; is the cofactor for the transformation
dtransform_asinh(di, cols, 5)

# normalize all dataset columns to mean=0 sdev=1
dscale(di, cols)</code></pre><h3 id="Create-a-Self-Organizing-MAP-(SOM)"><a class="docs-heading-anchor" href="#Create-a-Self-Organizing-MAP-(SOM)">Create a Self Organizing MAP (SOM)</a><a id="Create-a-Self-Organizing-MAP-(SOM)-1"></a><a class="docs-heading-anchor-permalink" href="#Create-a-Self-Organizing-MAP-(SOM)" title="Permalink"></a></h3><p>With the data prepared, running the SOM algorithm is straightforward:</p><pre><code class="language-julia"># randomly initialize the SOM
som = initGigaSOM(di, 16, 16)

# train the SOM for 20 epochs (10 is default, but nothing will happen if the
# epochs are slightly overdone)
som = trainGigaSOM(som, di, epochs = 20)</code></pre><p>Finally, calculate the clustering:</p><pre><code class="language-julia">somClusters = mapToGigaSOM(som, di)</code></pre><h3 id="FlowSOM-style-metaclustering"><a class="docs-heading-anchor" href="#FlowSOM-style-metaclustering">FlowSOM-style metaclustering</a><a id="FlowSOM-style-metaclustering-1"></a><a class="docs-heading-anchor-permalink" href="#FlowSOM-style-metaclustering" title="Permalink"></a></h3><p>One disadvantage of SOMs is that they output a large amount of small clusters that are relatively hard to interpret manually. FlowSOM improved that situation by running a &quot;clustering on clusters&quot; (metaclustering) that address the problem.</p><p>In this example, we reduce the original 256 small clusters from 16x16 SOM to only 10 &quot;metaclusters&quot;, using the standard hierarchical clustering:</p><pre><code class="language-julia">using Clustering
import Distances
metaClusters =
  cutree(k=10,
         hclust(linkage=:average,
            GigaSOM.distMatrix(Distances.Euclidean())(som.codes)))</code></pre><p>The <code>metaClusters</code> represent membership of the SOM codes in cluster; these can be expanded to membership of all cells using <a href="../../functions/#GigaSOM.mapToGigaSOM-Tuple{Som,Any}"><code>mapToGigaSOM</code></a>:</p><pre><code class="language-julia">mapping = distributed_collect(mapToGigaSOM(som, di), free=true)
clusters = metaClusters[mapping]</code></pre><p><code>clusters</code> now contain an integer from <code>1</code> to <code>10</code> with a classification of each cell in the dataset.</p><p>(The argument <code>free=true</code> of <code>distributed_collect</code> automatically removes the distributed data from workers after collecting, which saves their memory for other datasets.)</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../basicUsage/">« Introduction</a><a class="docs-footer-nextpage" href="../distributedProcessing/">Advanced distributed processing »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 1 February 2021 13:02">Monday 1 February 2021</span>. Using Julia version 1.3.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
