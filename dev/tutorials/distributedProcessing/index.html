<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Advanced distributed processing · GigaSOM.jl</title><link rel="canonical" href="https://lcsb-biocore.github.io/GigaSOM.jl/stable/tutorials/distributedProcessing/"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/gigasomlogotransp.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="GigaSOM.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">GigaSOM.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../background/">Background</a></li><li><span class="tocitem">Tutorial</span><ul><li><a class="tocitem" href="../basicUsage/">Introduction</a></li><li><a class="tocitem" href="../processingFCSData/">Cytometry data</a></li><li class="is-active"><a class="tocitem" href>Advanced distributed processing</a><ul class="internal"><li><a class="tocitem" href="#Manual-work-with-the-distributed-data"><span>Manual work with the distributed data</span></a></li><li><a class="tocitem" href="#Convenience-statistical-functions"><span>Convenience statistical functions</span></a></li></ul></li><li><a class="tocitem" href="../whereToGoNext/">Conclusion</a></li></ul></li><li><a class="tocitem" href="../../functions/">Functions</a></li><li><a class="tocitem" href="../../howToContribute/">How to contribute</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorial</a></li><li class="is-active"><a href>Advanced distributed processing</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Advanced distributed processing</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/LCSB-BioCore/GigaSOM.jl/blob/master/docs/src/tutorials/distributedProcessing.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Tutorial-3:-Distributed-data-processing-and-statistics"><a class="docs-heading-anchor" href="#Tutorial-3:-Distributed-data-processing-and-statistics">Tutorial 3: Distributed data processing and statistics</a><a id="Tutorial-3:-Distributed-data-processing-and-statistics-1"></a><a class="docs-heading-anchor-permalink" href="#Tutorial-3:-Distributed-data-processing-and-statistics" title="Permalink"></a></h1><p>If you can get the data on a single machine, computation of various statistics can be performed using standard Julia functions. With large datasets that do not fit on a computer, things get more complicated. Luckily, many statistics and algorithms possess parallel, map-reduce-style implementations that can be used to address this problem.</p><p>For example, the <a href="../../functions/#GigaSOM.dstat-Tuple{LoadedDataInfo,Array{Int64,1}}"><code>dstat</code></a> function computes sample statistics without fetching all data to a single node. You can use it in a way similar to aforementioned <code>dselect</code> and <code>dtransform_asinh</code>. The following code extracts means and standard deviations from the first 3 columns of a dataset distributed as <code>di</code>:</p><pre><code class="language-julia">dstat(di, [1,2,3])</code></pre><h2 id="Manual-work-with-the-distributed-data"><a class="docs-heading-anchor" href="#Manual-work-with-the-distributed-data">Manual work with the distributed data</a><a id="Manual-work-with-the-distributed-data-1"></a><a class="docs-heading-anchor-permalink" href="#Manual-work-with-the-distributed-data" title="Permalink"></a></h2><p>We will first show how to use the general framework to compute per-cluster statistics. GigaSOM exports the <a href="../../functions/#GigaSOM.distributed_mapreduce-NTuple{4,Any}"><code>distributed_mapreduce</code></a> function that can be used as a very effective basic building block for running such computations. For example, you can efficiently compute a distributed mean of all your data as such:</p><pre><code class="language-julia">distributed_mapreduce(di, sum, +) / distributed_mapreduce(di, length, +)</code></pre><p>The parameters of <code>distributed_mapreduce</code> are, in order:</p><ul><li><code>di</code>, the dataset</li><li><code>sum</code> or <code>length</code>, an unary &quot;map&quot; function – during the computation, each piece of distributed data is first <em>paralelly</em> processed by this function</li><li><code>+</code>, a binary &quot;reduction&quot; or &quot;folding&quot; function – the pieces of information processed by the map function are successively joined in pairs using this function, until there is only a single result left. This final result is also what <code>distributed_mapreduce</code> returns.</li></ul><p>Above example thus reads: Sum all data on all workers, add up the intermediate results, and divide the final number to the sum of all lengths of data on the workers.</p><p>Column-wise mean (as produced by <code>dstat</code>) is slightly more useful; we only need to split the computation on columns:</p><pre><code class="language-julia">distributed_mapreduce(di, d -&gt; mapslices(sum, d, dims=1), +) ./ distributed_mapreduce(di, x-&gt;size(x,1), +)</code></pre><p>Finally, for distributed computation of per-cluster mean, the clustering information needs to be distributed as well (Fortunately, that is easy, because the distributed <code>mapToGigaSOM</code> does exactly that).</p><p>First, compute the clustering:</p><pre><code class="language-julia">mapping = mapToGigaSOM(som, di)
distributed_transform(mapping, m -&gt; metaClusters[m])</code></pre><p>Now, the distributed computation is run on 2 scattered datasets. We employ a helper function <code>mapbuckets</code> which provides bucket-wise execution of a function, in a way very similar to <code>mapslices</code>. (In the example, we actually use <code>catmapbuckets</code> that concatenates the result into a nice array.) The following code produces a matrix of tuples <code>(sum, count)</code>, for separate clusters (in rows) and data columns (in columns):</p><pre><code class="language-julia">sumscounts = distributed_mapreduce([di, mapping],
    (d, mapping) -&gt; catmapbuckets(
        (_,clData) -&gt; (sum(clData), length(clData)),
	d, 10, mapping),
    (a,b) -&gt; (((as,al),(bs,bl)) -&gt; ((as+bs), (al+bl))).(a,b))</code></pre><pre><code class="language-none">10×4 Array{Tuple{Float64,Int64},2}:
 (5949.71, 1228)  (-21.9789, 1228)  (12231.3, 1228)  (12303.1, 1228)
 (6379.98, 1246)  (12464.3, 1246)   (12427.9, 1246)  (12479.8, 1246)
 (6513.41, 1294)  (12968.8, 1294)   (12960.7, 1294)  (-28.1922, 1294)
 (6312.37, 1236)  (-26.7392, 1236)  (6.74384, 1236)  (12401.7, 1236)
 (6395.73, 1285)  (12867.7, 1285)   (-52.653, 1285)  (-26.9795, 1285)
 (6229.72, 622)   (10.7578, 622)    (6200.1, 622)    (0.882128, 622)
 (6141.97, 612)   (6078.56, 612)    (45.9878, 612)   (6079.3, 612)
 (51.3709, 616)   (23.4306, 616)    (6117.53, 616)   (1.15342, 616)
 (6177.16, 1207)  (-50.4624, 1207)  (48.8023, 1207)  (-5.549, 1207)
 (8.56597, 654)   (6536.1, 654)     (-29.2208, 654)  (6539.94, 654)</code></pre><p>With a bit of Julia, this can be aggregated to actual per-cluster means:</p><pre><code class="language-julia">clusterMeans = [ sum/count for (sum,count) in sumcounts ]</code></pre><pre><code class="language-none">10×4 Array{Float64,2}:
  4.84504    -0.0178982   9.96031     10.0188
  5.12037    10.0034      9.97428     10.0159
  5.03354    10.0223     10.016       -0.0217869
  5.10709    -0.0216336   0.00545618  10.0337
  4.97722    10.0138     -0.0409751   -0.0209958
 10.0156      0.0172955   9.968        0.00141821
 10.0359      9.93229     0.0751434    9.9335
  0.0833944   0.0380366   9.93105      0.00187243
  5.11778    -0.0418081   0.0404327   -0.00459735
  0.0130978   9.99403    -0.0446802    9.99991</code></pre><p>Since we used the data from the hypercube dataset from the beginning of the tutorial, you should be able to recognize several clusters that perfectly match the hypercube vertices (although not all, because <code>k=10</code> is not enough to capture all of the actual 16 existing clusters)</p><p>Finally, we can remove the temporary data from workers to create free memory for other analyses:</p><pre><code class="language-julia">undistribute(mapping)</code></pre><h2 id="Convenience-statistical-functions"><a class="docs-heading-anchor" href="#Convenience-statistical-functions">Convenience statistical functions</a><a id="Convenience-statistical-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Convenience-statistical-functions" title="Permalink"></a></h2><p>Notably, several of the most used statistical functions are available in GigaSOM.jl in a form that can cope with distributed data.</p><p>For example, you can run a distributed median computation as such:</p><pre><code class="language-julia">dmedian(di, [1,2,3,4])</code></pre><p>In the hypercube dataset, the medians are slightly off-center because there is a lot of empty space between the clusters:</p><pre><code class="language-none">3-element Array{Float64,1}:
 6.947097488861494
 7.934405685940568
 7.069149844215707
 2.558892109203585</code></pre><p><code>dstat</code> function has a bucketed variant that can split the statistics among different clusters. This computes the per-cluster standard deviations of the dataset:</p><pre><code class="language-julia">dstat_buckets(di, 10, mapping, [1,2,3,4])[2]</code></pre><p>In the result, we can count 4 &quot;nice&quot; clusters, and 6 clusters that span 2 of the original clusters, totally giving 16. (Hypercube validation succeeded!)</p><pre><code class="language-none">10×4 Array{Float64,2}:
 5.09089   0.997824  1.01815   0.980758
 5.13971   1.02019   0.977637  1.00124
 5.13209   0.974332  1.00058   0.99874
 5.11529   0.998166  1.01825   1.01885
 5.10542   1.01686   0.975993  0.991992
 0.991075  0.993312  1.00667   1.05048
 0.996443  1.02699   0.938742  0.98831
 0.946917  0.989543  1.0056    0.999609
 5.09963   1.00131   0.978803  0.984435
 1.00892   0.998226  1.05538   0.994829</code></pre><p>A similar bucketed version is available for computation of medians:</p><pre><code class="language-julia">dmedian_buckets(di, 10, mapping, [1,2,3,4])</code></pre><p>Note that the cluster medians are similar to means, except for the cases when the cluster is formed by 2 actual data aggregations (e.g. on the second row), where medians dodge the empty space in the middle of the data:</p><pre><code class="language-none">10×4 Array{Float64,2}:
  1.97831    -0.0120118    9.98967    10.0161
  7.99438    10.0263       9.9988     10.0033
  3.27907     9.98728     10.0254      0.00444198
  7.91739    -0.0623953   -0.0240277  10.0374
  2.445      10.0101      -0.0471141  -0.0253346
 10.0121      0.00935064   9.94992     0.0459787
 10.0512      9.93359      0.0923141   9.91175
  0.0675462  -0.0142712    9.93406     0.0343599
  8.09972    -0.0217352    0.0575258  -0.010485
 -0.0183372  10.0392      -0.115253   10.0101</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../processingFCSData/">« Cytometry data</a><a class="docs-footer-nextpage" href="../whereToGoNext/">Conclusion »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 7 October 2020 05:18">Wednesday 7 October 2020</span>. Using Julia version 1.3.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
